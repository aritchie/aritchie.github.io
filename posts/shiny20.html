<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>Allan Ritchie - Shiny 2.0 For Xamarin - Shinier Than Ever</title>

  <link rel="canonical" href="https://aritchie.github.io/posts/shiny20">

      <link type="application/rss+xml" rel="alternate" title="Allan Ritchie&#x27;s Blog" href="/Xamarin.rss" />
      <link type="application/rss+xml" rel="alternate" title="Personal Blog of Allan Ritchie" href="/feed.rss" />
      <link type="application/atom+xml" rel="alternate" title="Personal Blog of Allan Ritchie" href="/feed.atom" />

  <meta name="application-name" content="Allan Ritchie" />
  <meta name="msapplication-tooltip" content="Allan Ritchie" />
  <meta name="msapplication-starturl" content="/" />

  <meta property="og:title" content="Shiny 2.0 For Xamarin - Shinier Than Ever" />
    <meta property="og:image" content="https://aritchie.github.io/images/shiny_logo.png" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://aritchie.github.io/posts/shiny20" />

  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/favicon.ico" type="image/x-icon">

  <!-- Bootstrap core CSS -->
  <link href="/vendor/bootstrap/scss/bootstrap.css" rel="stylesheet">

  <!-- Custom fonts for this template -->
  <link href="/vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
  <link href="/vendor/fontawesome-free/css/brands.min.css" rel="stylesheet" type="text/css">
  <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css' data-no-mirror>
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css' data-no-mirror>

  <!-- Custom styles for this template -->
  <link href="/scss/clean-blog.css" rel="stylesheet">

  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.19.0/components/prism-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.19.0/plugins/autoloader/prism-autoloader.min.js" data-no-mirror></script>
  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.0.0/dist/quicklink.umd.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.19.0/themes/prism.css">

  <link href="/scss/TabGroup.css" rel="stylesheet" type="text/css">


  

</head>

<body>

  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="/">Allan Ritchie</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
            <li class="nav-item">
                <a class="nav-link" href="/posts">Posts</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="/tags">Tags</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="/about">About</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="/projects">Projects</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="/speaking">Speaking</a>
            </li>
</ul>
    </div>
  </div>
</nav>

  <!-- Page Header -->
  <header class="masthead" style="background-image: url(&quot;/images/shiny_logo.png&quot;)">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        <div class="post-heading">
          <h1>
            Shiny 2.0 For Xamarin - Shinier Than Ever
          </h1>
              <div class="meta">Published on Wednesday, May 5, 2021</div>
                <div class="mt-3">
                      <a href="/tags/xamarin" class="badge badge-light"> Xamarin</a>
                      <a href="/tags/oss" class="badge badge-light"> OSS</a>
                      <a href="/tags/shiny" class="badge badge-light"> Shiny</a>
                </div>
        </div>
      </div>
    </div>
  </div>
</header>

  <!-- Main Content -->
  <div class="container">
    <div class="row">
      <div id="content" class="col-md-12">
        <h2 id="the-path-to-2.0">The Path to 2.0</h2>
<p>Shiny is a Xamarin Framework designed to make dealing with device &amp; background services easy by bringing things like dependency injection, logging, and lots of utilities to bring your workflows to the background
in friendly, testable, way!</p>
<p>Version 2.0 is months of work, hundreds of commits (1166 to be exact), and a lot of discovery around how to improve the end experience.  This release focused on improving the background experience
even more especially on Android.  Android is the source of great pain when it comes to backgrounding and especially around expectations that people
have (for instance, real time background GPS).  As such, Shiny now uses foreground services in most of these places.  As a developer using Shiny, this is completely
transparent change for you unless you want to customize the notification.</p>
<p>Now that I'm done with the boring rant.  Let's talk about some of the cool new features</p>
<ul>
<li><a href="#death-to-boilerplate-code">Boilerplate Code</a></li>
<li><a href="#static-class-generation">Static Class Generation</a></li>
<li><a href="#logging">Microsoft Extensions Logging</a></li>
<li><a href="#bluetooth-le">BluetoothLE</a></li>
<li><a href="#notifications">Local Notifications</a></li>
<li><a href="#push-notifications">Push Notifications</a></li>
<li><a href="#beacons">Beacons</a></li>
</ul>
<h2 id="death-to-boilerplate-code">Death to Boilerplate Code</h2>
<hr />
<p>This was the first source of support pain and issues that users had was usually missed (or wrong) setup.  In 2.0, I set out for how to remove this issue.  With the latest C# 9/.NET5 release,
source generators were released.  This allows for code to be injected in the places Shiny needed it.  To make things even more convenient for users, I can also wire up all of their
Xamarin Forms, Xamarin Essentials, and other 3rd party source code.</p>
<p>To get an idea, here is a before and after showing both iOS and Android boilerplate</p>
<div class="tab-wrap">
<input type="radio" id="b60e570af3824c3aae16fdb4497d3552-eca8c563cfb54662b836fbfcc447f0d3" name="b60e570af3824c3aae16fdb4497d3552" class="tab" checked><label for="b60e570af3824c3aae16fdb4497d3552-eca8c563cfb54662b836fbfcc447f0d3" >Android Before</label>
<input type="radio" id="b60e570af3824c3aae16fdb4497d3552-0036cd19f55d42258fd74d3226b616a2" name="b60e570af3824c3aae16fdb4497d3552" class="tab" ><label for="b60e570af3824c3aae16fdb4497d3552-0036cd19f55d42258fd74d3226b616a2" >Android After</label>
<input type="radio" id="b60e570af3824c3aae16fdb4497d3552-bd1762ce8f574183b103e543805a1052" name="b60e570af3824c3aae16fdb4497d3552" class="tab" ><label for="b60e570af3824c3aae16fdb4497d3552-bd1762ce8f574183b103e543805a1052" >iOS Before</label>
<input type="radio" id="b60e570af3824c3aae16fdb4497d3552-2aca279246f84a2fb26db99e800ce04b" name="b60e570af3824c3aae16fdb4497d3552" class="tab" ><label for="b60e570af3824c3aae16fdb4497d3552-2aca279246f84a2fb26db99e800ce04b" >iOS After</label>
<div class="tab__content">

<pre><code class="language-csharp">// Android App
[global::Android.App.ApplicationAttribute]
public partial class MainApplication : global::Android.App.Application
{
	public MainApplication(IntPtr handle, JniHandleOwnership transfer) : base(handle, transfer) {}

	public override void OnCreate()
	{
		this.ShinyOnCreate(new Samples.SampleStartup());
		global::Xamarin.Essentials.Platform.Init(this);
		base.OnCreate();
	}
}

// Android Activity
public partial class MainActivity
{
	protected override void OnCreate(Bundle savedInstanceState)
	{
		this.ShinyOnCreate();
		TabLayoutResource = Resource.Layout.Tabbar;
		ToolbarResource = Resource.Layout.Toolbar;
		base.OnCreate(savedInstanceState);
		global::Xamarin.Forms.Forms.Init(this, savedInstanceState);
		this.LoadApplication(new Samples.App());
	}

	protected override void OnNewIntent(Intent intent)
	{
		base.OnNewIntent(intent);
		this.ShinyOnNewIntent(intent);
	}

	protected override void OnActivityResult(int requestCode, Result resultCode, Intent data)
	{
		base.OnActivityResult(requestCode, resultCode, data);
		this.ShinyOnActivityResult(requestCode, resultCode, data);
	}

	public override void OnRequestPermissionsResult(int requestCode, string[] permissions, [GeneratedEnum] Permission[] grantResults)
	{
		base.OnRequestPermissionsResult(requestCode, permissions, grantResults);
		this.ShinyOnRequestPermissionsResult(requestCode, permissions, grantResults);
		global::Xamarin.Essentials.Platform.OnRequestPermissionsResult(requestCode, permissions, grantResults);
	}
}
</code></pre>


</div>
<div class="tab__content">

<pre><code class="language-csharp">// Android Application - you don't even have to make one
// Android Activity
public partial class MainActivity : Xamarin.Forms.Platform.Android.FormsAppCompatActivity
{
}

[assembly: ShinyApplication(
	ShinyStartupTypeName = &quot;Samples.SampleStartup&quot;,
	XamarinFormsAppTypeName = &quot;Samples.App&quot;
)]
</code></pre>


</div>
<div class="tab__content">

<pre><code class="language-csharp">// iOS AppDelegate - all features used
public partial class AppDelegate
{
	public override bool FinishedLaunching(UIApplication app, NSDictionary options)
	{
		this.ShinyFinishedLaunching(new Samples.SampleStartup());
		global::Xamarin.Forms.Forms.Init();
		// third party inits
		this.LoadApplication(new Samples.App());
		return base.FinishedLaunching(app, options);
	}
	public override void RegisteredForRemoteNotifications(UIApplication application, NSData deviceToken) =&gt; this.ShinyRegisteredForRemoteNotifications(deviceToken);
	public override void DidReceiveRemoteNotification(UIApplication application, NSDictionary userInfo, Action&lt;UIBackgroundFetchResult&gt; completionHandler) =&gt; this.ShinyDidReceiveRemoteNotification(userInfo, completionHandler);
	public override void FailedToRegisterForRemoteNotifications(UIApplication application, NSError error) =&gt; this.ShinyFailedToRegisterForRemoteNotifications(error);
	public override void PerformFetch(UIApplication application, Action&lt;UIBackgroundFetchResult&gt; completionHandler) =&gt; this.ShinyPerformFetch(completionHandler);
	public override void HandleEventsForBackgroundUrl(UIApplication application, string sessionIdentifier, Action completionHandler) =&gt; this.ShinyHandleEventsForBackgroundUrl(sessionIdentifier, completionHandler);
}
</code></pre>


</div>
<div class="tab__content">

<pre><code class="language-csharp">[Register(&quot;AppDelegate&quot;)]
public partial class AppDelegate : Xamarin.Forms.Platform.iOS.FormsApplicationDelegate
{
}

[assembly: ShinyApplication(
	ShinyStartupTypeName = &quot;Samples.SampleStartup&quot;,
	XamarinFormsAppTypeName = &quot;Samples.App&quot;
)]
</code></pre>


</div>
</div>

<p>To get this &quot;voodoo&quot; magic.  Simply install the <a href="https://www.nuget.org/packages/Shiny/" target="Shiny"><img src="https://img.shields.io/nuget/v/Shiny.svg?style=for-the-badge&label=Shiny" /></a> nuget package into your head projects and add the attribute as shown in the &quot;after&quot; tabs above.  Also note how the activity and appdelegate are partial.
These new generators can even build your entire startup class, but that's a discussion for a future article :)</p>
<p><strong>NOTE: If you are using this on Azure DevOps or CI systems, MSBuild 16.8 is required which is not part of Mono yet.  You need to use a tool like Boots to update to the latest beta OR simply use the &quot;BEFORE&quot; versions above and install <a href="https://www.nuget.org/packages/Shiny.Core/" target="Shiny.Core"><img src="https://img.shields.io/nuget/v/Shiny.Core.svg?style=for-the-badge&label=Shiny.Core" /></a> instead</strong></p>
<h2 id="static-class-generation">Static Class Generation</h2>
<hr />
<p>There are a lot of users that don't like dependency injection.  I can't see or live in a world without it (for now).<br />
With those thoughts in mind, source generators once again came to the rescue.  All you need to do is install the <a href="https://www.nuget.org/packages/Shiny/" target="Shiny"><img src="https://img.shields.io/nuget/v/Shiny.svg?style=for-the-badge&label=Shiny" /></a> in the library where you want the classes generated and add the attribute in any file as shown below.
For any Shiny library you have installed in your library, the source generator will create a static equivalent class of the interface.</p>
<pre><code class="language-csharp">[assembly: StaticClasses(&quot;ILikeStatics&quot;)]

// core jobs
ILikeStatics.ShinyJobs.Register(...);

// ble
ILikeStatics.ShinyBle.Scan();

</code></pre>
<p>Pretty statics and NO dependency injection to be seen anywhere.  You still have to create a startup file though ;)</p>
<h2 id="logging">Logging</h2>
<hr />
<p>Logging is generally something you want in your app.  When you work in the background, you can't rely on the general dev experience of errors appearing in your VS output window.<br />
While libraries like AppCenter and Firebase help with crashes, it can be quite dangerous to build them directly into all of your views/viewmodels/classes/etc. Logging providers also tend to disappear and change over time.</p>
<p>With that being said, I also didn't want to write new providers to plugin into Shiny.  There was an easy answer to this problem - Use Microsoft.Extensions.Logging - the exact same library used by ASP.NET Core devs!  It is a fantastical abstraction
to build on and support DI out of the gate!  The only thing that was missing was logging providers for AppCenter &amp; Firebase - so I've added the following libs to Shiny</p>
<a href="https://www.nuget.org/packages/Shiny.Logging.Firebase/" target="Shiny.Logging.Firebase"><img src="https://img.shields.io/nuget/v/Shiny.Logging.Firebase.svg?style=for-the-badge&label=Shiny.Logging.Firebase" /></a>
<a href="https://www.nuget.org/packages/Shiny.Logging.AppCenter/" target="Shiny.Logging.AppCenter"><img src="https://img.shields.io/nuget/v/Shiny.Logging.AppCenter.svg?style=for-the-badge&label=Shiny.Logging.AppCenter" /></a>
<p>Wiring providers up is also almost just like ASP.NET Core.  In your Shiny startup file:</p>
<pre><code class="language-csharp">using System;
using Shiny;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;


namespace YourApp
{
    public class YourStartup : ShinyStartup
    {
        public override void ConfigureLogging(ILoggingBuilder builder, IPlatform platform)
        {
			builder.AddFirebase();
			builder.AddAppCenter(&quot;your appcenter key&quot;);
        }
	}
}

</code></pre>
<h2 id="notifications">Notifications</h2>
<hr />
<p>Notifications in Shiny still provide all of the features imaginable for your Xamarin cross platform needs.</p>
<ul>
<li>Scheduling</li>
<li>Actions</li>
<li>Sounds</li>
<li>Priorities</li>
</ul>
<p>With 2.0, Notifications had to undergo some changes to make sure things like sounds worked and response actions from notifications were consistent across platforms, thus, channels were
created as to play ball properly with channels on Android and to a far lesser degree, categories on iOS.</p>
<p>Channels are essentially configuration groups.  This provides equivalent functionality to what you find on Android 8+ such as</p>
<ul>
<li>Priority</li>
<li>Sounds</li>
<li>Actions - Text Replies, Buttons, etc</li>
</ul>
<p>With iOS, &quot;channels&quot; equate in a way to categories, but apply more to the available actions on a given notification.  With that in mind, I had to bring these two
worlds together for a consistent design between them (oh... and that UWP thing can come along too).  What's better, channel is required on Android - if you don't care
about the additional functionality - omit it and Shiny will default it for you!</p>
<pre><code class="language-cs">var manager = ShinyHost.Resolve&lt;Shiny.Notifications.INotificationManager&gt;(); // INJECT THIS
await manager.AddChannel(new Channel 
{
	Identifier = &quot;YourChannelName&quot;,
	Description = &quot;This is your channel&quot;,
	Importance = ChannelImportance.Normal // normal+ will add default sounds on android
	CustomSoundPath = &quot;notification.mp3&quot;,
	Actions =
	{
		new ChannelAction
		{
			Identifier = &quot;message&quot;,
			Title = &quot;Leave a Message&quot;,
			ActionType = ChannelActionType.TextReply
		},
		new ChannelAction
		{
			Identifier = &quot;freeticket&quot;,
			Title = &quot;Free Ticket&quot;,
			ActionType = ChannelActionType.Destructive
		}
	}
});

// BONUS - got a resource file that you want to use instead - make sure to call this before AddChannel
channel.SetSoundFromEmbeddedResource(this.GetType().Assembly, &quot;Samples.Resources.notification.mp3&quot;);


// now to use it
await manager.Send(
	&quot;WELCOME TO THE CN Tower&quot;,
	&quot;What would you like to do?&quot;,
	&quot;YourChannelName&quot;
)

</code></pre>
<p>Which gives you this!</p>
<p><img src="images/shiny20/notificationactions.gif" alt="Actions1" /></p>
<h2 id="push-notifications">Push Notifications</h2>
<hr />
<p>Over the last few years, push notification providers have come and gone.  Google has gone from GCM to Firebase - Other 3rd party push providers have dropped like flies for one reasons or another (ie. AppCenter).
If you don't have a good design pattern in place, you aren't left a rough spot of being forced to refactor things.</p>
<p>As of the 2.0 release, Shiny supports:</p>
<ul>
<li>Native</li>
<li>Firebase</li>
<li>Azure Notification Hubs</li>
<li>With OneSignal &amp; AWS coming in the near future</li>
</ul>
<p>Why is this such an awesome API? Because you can swap between push notification providers with 1 single line of code:</p>
<pre><code class="language-csharp">using Microsoft.Extensions.DependencyInjection;
using Shiny;

namespace YourNamespace
{
    public class YourShinyStartup : ShinyStartup
    {
        public override void ConfigureServices(IServiceCollection services, IPlatform platform)
        {
            
				// NATIVE
				services.UsePush&lt;MyPushDelegate&gt;(); // native
       
				// OR FIREBASE 
				services.UseFirebaseMessaging&lt;MyPushDelegate&gt;();

				// OR AZURE NOTIFICATION HUBS
				services.UsePushAzureNotificationHubs&lt;MyPushDelegate&gt;(
					&quot;Your Listener Connection String&quot;,
					&quot;Your Hub Name&quot;
				);

        }
    }
}
</code></pre>
<p>This doesn't cover the general push setup like the Info/Entitlements.plist setup and google-services.json.  This will be covered in the docs.</p>
<p>Now that we've wired it up, let's request the user permission and get a token.</p>
<pre><code class="language-csharp">var result = await ShinyHost.Resolve&lt;Shiny.Push.IPushManager&gt;.RequestAccess();
if (result.Status == Shiny.AccessState.Available) 
{
    result.RegistrationToken; // maybe you want to send this to your server to use in notifications
}

</code></pre>
<p>And lastly, how you actually get &quot;pushes&quot;.  This method is particularily useful if you are doing a real time app for something like chat.</p>
<p><em><strong>Foreground</strong></em></p>
<pre><code class="language-csharp">var subscription = ShinyHost
	.Resolve&lt;Shiny.Push.IPushManager&gt;()
	.WhenReceived(push =&gt; {
		var value = push.Data[&quot;ThisIsADictionary&quot;];
		var title = push.Notification?.Title; // warning: notifications can be null
	});

// make sure to dispose when you're done or going to the background
subscription.Dispose();
</code></pre>
<p><em><strong>Background (this still runs in the foreground)</strong></em>
The background, as with all things in Shiny, is where things begin to shine. The OnReceived is where most of the magic will happen for you.  From here, you can process a push notification
and do things like call out to an HTTP service to refresh data, maybe acknowledge that your user is available for shift work if they have &quot;punched&quot; into your app.</p>
<pre><code class="language-csharp">using Shiny.Push;
using System.Threading.Tasks;

namespace Shiny20Sample
{
    public class MyPushDelegate : IPushDelegate
    {
        public async Task OnEntry(PushNotificationResponse response)
        {
        }

        public async Task OnReceived(PushNotification notification)
        {
        }

        public async Task OnTokenChanged(string token)
        {
        }
    }
}
</code></pre>
<h3 id="tag-support">Tag Support</h3>
<p>Tags are a way of telling the push provider (if supported), I want to listen to these &quot;topics&quot;.  This is supported by all of the 3rd party
messaging systems like Firebase &amp; Azure Notifications Hubs.</p>
<pre><code class="language-csharp">// will not be null if supported
var tagPushManager = ShinyHost.Resolve&lt;IPushManager&gt;() as IPushTagSupport;
await tagPushManager.AddTag(&quot;YourTag&quot;);
await tagPushManager.RemoveTag(&quot;YourTag&quot;);
await tagPushManager.ClearTags();
await tagPushManager.SetTags(&quot;tag1&quot;, &quot;tag2&quot;); // remove tags that aren't present and add new tags
tagPushManager.RegisteredTags; // your current set of registered tags

// OR use the friendly extension methods off the push manager
var push = ShinyHost.Resolve&lt;IPushManager&gt;();
await push.TryAddTag(...);
await push.TryRemoveTag(...);
await push.TryClearTags(...);

</code></pre>
<h2 id="bluetooth-le">Bluetooth LE</h2>
<hr />
<p>I really went through all of the API calls this library had to offer.</p>
<p>BLE is still firmly (and always will be) rooted in Reactive Extensions, but I wanted to make the APIs easier to consume for all users including myself.</p>
<p>Today, I'm only going to talk about 2 of the super cool features that are new with 2.0.  The Managed BLE mechanics:</p>
<h4 id="managed-scans">Managed Scans</h4>
<p>Scanning was riddled with potential issues</p>
<ul>
<li>maintaining a list of unique peripherals while still watching things like the RSSI and name changes</li>
<li>synchronizing list updates to your UI</li>
<li>Removing a device from the list that hasn't been heard in a specific time</li>
<li>preventing the scan from overwhelming your UI with redraws (and subsequently making sure you're on the UI thread when doing anything)</li>
</ul>
<p>It took a fair of code to manage this even with Shiny, but with the new managed scanner - take a look at the difference:</p>
<div class="tab-wrap">
<input type="radio" id="f933d00611bc4d959f44a7bf5710822f-225eb29d2db5451a96d737a3aba0952d" name="f933d00611bc4d959f44a7bf5710822f" class="tab" checked><label for="f933d00611bc4d959f44a7bf5710822f-225eb29d2db5451a96d737a3aba0952d" >Before</label>
<input type="radio" id="f933d00611bc4d959f44a7bf5710822f-7523fc25ea50458b88f08919193cc9c4" name="f933d00611bc4d959f44a7bf5710822f" class="tab" ><label for="f933d00611bc4d959f44a7bf5710822f-7523fc25ea50458b88f08919193cc9c4" >After</label>
<div class="tab__content">

<p>This isn't even doing things like removing items if a peripheral isn't seen for a configured amount of seconds.</p>
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Reactive.Linq;
using System.Windows.Input;
using ReactiveUI;
using ReactiveUI.Fody.Helpers;
using Samples.Infrastructure;
using Shiny;
using Shiny.BluetoothLE;


namespace Samples.BluetoothLE
{
    public class AdapterViewModel : ViewModel
    {
        IDisposable? scanSub;


        public AdapterViewModel(IBleManager bleManager)
        {
            this.ScanToggle = ReactiveCommand.CreateFromTask(
                async () =&gt;
                {
                    if (this.IsScanning)
                    {
                        this.StopScan();
                    }
                    else
                    {
                        this.Peripherals.Clear();
                        this.IsScanning = true;

                        this.scanSub = bleManager
                            .Scan()
                            .Buffer(TimeSpan.FromSeconds(1))
                            .SubOnMainThread(
                                results =&gt;
                                {
                                    var list = new List&lt;PeripheralItemViewModel&gt;();
                                    foreach (var result in results)
                                    {
                                        var peripheral = this.Peripherals.FirstOrDefault(x =&gt; x.Equals(result.Peripheral));
                                        if (peripheral == null)
                                            peripheral = list.FirstOrDefault(x =&gt; x.Equals(result.Peripheral));

                                        if (peripheral != null)
                                        {
                                            peripheral.Update(result);
                                        }
                                        else
                                        {
                                            peripheral = new PeripheralItemViewModel(result.Peripheral);
                                            peripheral.Update(result);
                                            list.Add(peripheral);
                                        }
                                    }
                                    if (list.Any())
                                    {
                                        // XF is not able to deal with an observablelist/addrange properly
                                        foreach (var item in list)
                                            this.Peripherals.Add(item);
                                    }
                                }
                            );
                    }
                }
            );
        }


        public ICommand ScanToggle { get; }
        public ObservableCollection&lt;PeripheralItemViewModel&gt; Peripherals { get; } = new ObservableCollection&lt;PeripheralItemViewModel&gt;();
        [Reactive] public PeripheralItemViewModel? SelectedPeripheral { get; set; }
        [Reactive] public bool IsScanning { get; private set; }


        void StopScan()
        {
            this.scanSub?.Dispose();
            this.scanSub = null;
            this.IsScanning = false;
        }
    }


    public class PeripheralItemViewModel : ViewModel
    {
        public PeripheralItemViewModel(IPeripheral peripheral)
            =&gt; this.Peripheral = peripheral;


        public override bool Equals(object obj)
            =&gt; this.Peripheral.Equals(obj);

        public IPeripheral Peripheral { get; }
        public string Uuid =&gt; this.Peripheral.Uuid;

        [Reactive] public string Name { get; private set; }
        [Reactive] public int Rssi { get; private set; }
        [Reactive] public string LocalName { get; private set; }
        [Reactive] public int TxPower { get; private set; }


        public void Update(ScanResult result)
        {
            this.Name = this.Peripheral.Name;
            this.Rssi = result.Rssi;
        }
    }
}
</code></pre>


</div>
<div class="tab__content">

<pre><code class="language-csharp">using System;
using System.Collections.ObjectModel;
using System.Reactive.Linq;
using System.Windows.Input;
using ReactiveUI;
using ReactiveUI.Fody.Helpers;
using Shiny;
using Shiny.BluetoothLE;
using Shiny.BluetoothLE.Managed;


namespace Samples.BluetoothLE
{
    public class ManagedScanViewModel : ViewModel
    {
        readonly IManagedScan scanner;


        public ManagedScanViewModel(IBleManager bleManager)
        {
            this.scanner = bleManager
                .CreateManagedScanner(RxApp.MainThreadScheduler, TimeSpan.FromSeconds(10))
                .DisposedBy(this.DeactivateWith);

            this.Toggle = ReactiveCommand.CreateFromTask(async () =&gt;
                this.IsBusy = await this.scanner.Toggle()
            );
        }


        public ICommand Toggle { get;  }
        [Reactive] public ManagedScanResult? SelectedPeripheral { get; set; }
        public ObservableCollection&lt;ManagedScanResult&gt; Peripherals
            =&gt; this.scanner.Peripherals;
    }
}


</code></pre>


</div>
</div>

<h4 id="managed-peripheral">Managed Peripheral</h4>
<p>The problem with traditional peripheral managed is that with every connection, you had to rescan for all of the services and characteristics you had.  You also had to restore any notifications you had.
This was painful.</p>
<p>Managed peripheral to the rescue. The managed peripheral will</p>
<ul>
<li>Work like a ViewModel - you can even have it broadcast it's changes on the UI thread for you to bind to</li>
<li>Reconnect automatically</li>
<li>Restore any characteristic subscription</li>
<li>Read/Writes will redetect the characteristics as you used them.  This saves using GetCharacteristic to continously and thereby increasing performance</li>
<li>Keeps a list of characteristics you've used instead of having to call GetServices/GetCharacteristics over and over</li>
</ul>
<div class="tab-wrap">
<input type="radio" id="7dc944f1c9c549209e28b1f2818a9459-90d7cf5c9718478b9592b5f140d333d0" name="7dc944f1c9c549209e28b1f2818a9459" class="tab" checked><label for="7dc944f1c9c549209e28b1f2818a9459-90d7cf5c9718478b9592b5f140d333d0" >Before</label>
<input type="radio" id="7dc944f1c9c549209e28b1f2818a9459-362a479513f24bd59fa778d1eaeba1eb" name="7dc944f1c9c549209e28b1f2818a9459" class="tab" ><label for="7dc944f1c9c549209e28b1f2818a9459-362a479513f24bd59fa778d1eaeba1eb" >After</label>
<div class="tab__content">

<pre><code class="language-csharp">// after a scan, you should have an IPeripheral
IGattCharacteristic reader;
IGattCharacteristic writer;
IGattCharacteristic notifier;

peripheral
    .WhenStatusChanged()
    .Subscribe(status =&gt; Device.BeginInvokeOnMainThread(() =&gt;
    {
        // let your user know what's going on
        ViewModelStatus = peripheral.Status;
    }));

peripheral
    .WhenConnected()
    .Subscribe(peripheral =&gt; 
    {
        // these have to be tossed everytime the connection state changes - if you used these out of scope (which you probably will), you need to safety them everywhere
        this.reader = await peripheral.GetCharacteristic(&quot;serviceUUID&quot;, &quot;characteristic&quot;);
        this.writer = await peripheral.GetCharacteristic(&quot;serviceUUID&quot;, &quot;characteristic&quot;);
        this.notifier = await peripheral.GetCharacteristic(&quot;serviceUUID&quot;, &quot;characteristic&quot;);
       
        this.notifier
            .WhenNotificationReceived()
            .Subscribe(data =&gt; Device.BeginInvokeOnMainThread(() =&gt; {
                ViewModelProperty = &quot;&quot;; // transform the data to a user value
            }));

        await this.notifier.EnableNotifications(true); // manage the error here!?
    });

peripheral
    .WhenNameChanged()
    .Subscribe(name =&gt; Device.BeginInvokeOnMainThread(() =&gt; ViewModelDeviceName = name)));

peripheral
    .ReadRssiContinuously()
    .ObserveOn(RxApp.MainThreadScheduler)
    .Subscribe(x =&gt; {
        // bind this to a viewmodel property
    });

// MAKE SURE TO CLEAN/UNSUBSCRIBE all of this junk when you're done with it!
</code></pre>


</div>
<div class="tab__content">

<pre><code class="language-csharp">// after a scan, you should have an IPeripheral
var managed = peripheral.CreateManaged(RxApp.MainThreadScheduler); // schedule 
managed.StartRssi(); // and StopRssi() later if you don't want it monitored

// now you can simply bind to these in your viewmodel
managed.Status;
managed.Rssi;
managed.Name;

// and the traditional methods
managed
    .WhenNotificationReceived(
        &quot;serviceUUID&quot;,
        &quot;characteristicUUID&quot;
    )
    .Subscribe(x =&gt; {
        // data for your viewmodel
    });

// note that you don't have to request a connection
await managed.EnableNotification(true, &quot;serviceUUID&quot;, &quot;characteristicUUID&quot;).ToTask(); // pass false when done

var readData = await managed.Read(&quot;serviceUUID&quot;, &quot;characteristicUUID&quot;).ToTask();
await managed.Write(&quot;serviceUUID&quot;, &quot;characteristicUUID&quot;, new byte[1] { 0x0 }).ToTask();

// when you're done with this guy, just dispose of him and he'll clean himself up and cancel the connection
managed.Dispose();
</code></pre>


</div>
</div>

<h2 id="beacons">Beacons</h2>
<hr />
<p>Beacons aren't really new, but there has always been a bit of a gap here in the Xamarin community.  You also had to always count on the beacon manufacturer supplying an SDK.
With Shiny, you get iBeacon (yes the Apple Beacons) out of the box on all of the platforms Shiny supports.  The thing I love about this library is that it is 100% C# and supports all of the monitoring/background scenarios
on Android as well!</p>
<p>Here's a quick look at the main beacon features</p>
<h3 id="the-wireup">The Wireup</h3>
<pre><code class="language-csharp">using Microsoft.Extensions.DependencyInjection;
using Shiny;

namespace YourNamespace
{
    public class YourShinyStartup : ShinyStartup
    {
        public override void ConfigureServices(IServiceCollection services, IPlatform platform)
        {
            
				// NOTE: there are 2 different services for beacons 
				// for ranging - finding individual beacons in the foreground
				services.UseBeaconRanging();
       
				// for monitoring - finding beacon groups (not individual beacons) in the background
				services.UseBeaconMonitoring&lt;MyBeaconMonitorDelegate&gt;();

        }
    }
}
</code></pre>
<h4 id="background-beacons">Background Beacons</h4>
<p>Setting up background monitoring is pretty simple.  Once you've registered, simply call:</p>
<p>Here's your delegate:</p>
<pre><code class="language-csharp">using Shiny.Beacons;
using System.Threading.Tasks;

namespace Shiny20Sample
{
    public class MyBeaconMonitorDelegate : IBeaconMonitorDelegate
    {
        public async Task OnStatusChanged(BeaconRegionState newStatus, BeaconRegion region)
        {
            // send notifications to say hello or goodbyte
            // call an http service to track your users
        }
    }
}
</code></pre>
<p>and the code to start monitoring:</p>
<pre><code class="language-csharp">await ShinyHost
	.Resolve&lt;Shiny.Beacons.IBeaconMonitorManager&gt;()
	.StartMonitoring(new BeaconRegion(...)) // from here, simply setup the filter criteria you need - remember you only get 20 on iOS!
</code></pre>
<p>Simple right!?  StartMonitoring will even request all of the appropropriate permissions!</p>
<h4 id="managed-ranging-scan">Managed Ranging Scan</h4>
<p>This essentially works identical to the new managed BLE scan shown earlier with all of the same benefits</p>
<ul>
<li>It will use best practices to ensure your UI isn't overwhelmed with updates</li>
<li>It will ensure that the bound collection is properly synchronized to prevent crashes</li>
<li>It will remove beacons from your list that haven't been &quot;heard&quot; in a configurable timestamp</li>
<li>It will manage the individual items with proximity changes</li>
</ul>
<div class="tab-wrap">
<input type="radio" id="590181b48b95403f9fa14b0eeec5d664-80e3acc0d776473eb42dda3557b37281" name="590181b48b95403f9fa14b0eeec5d664" class="tab" checked><label for="590181b48b95403f9fa14b0eeec5d664-80e3acc0d776473eb42dda3557b37281" >Before</label>
<input type="radio" id="590181b48b95403f9fa14b0eeec5d664-9318064faafd42cc848f2601f3449cb8" name="590181b48b95403f9fa14b0eeec5d664" class="tab" ><label for="590181b48b95403f9fa14b0eeec5d664-9318064faafd42cc848f2601f3449cb8" >After</label>
<div class="tab__content">

<pre><code class="language-csharp">
// your collection to bind to
public List&lt;BeaconViewModel&gt; Beacons { get; } = new List&lt;BeaconViewModel&gt;();

// don't forget to dispose of the subscription when you're done scanning
var scanSub = ShinyHost
    .Resolve&lt;Shiny.Beacons.IBeaconRangingManager&gt;()
    .WhenBeaconRanged(new BeaconRegion(&quot;yourid&quot;, &quot;Your Beacon UUID&quot;))
    .Synchronize(this.Beacons)
    .ObserveOn(RxApp.MainThreadScheduler) // borrowed from RX - if not, you can use XF Device.BeginInvokeOnMainThread in the subscribe
    .Subscribe(
        x =&gt;
        {
            var beacon = this.Beacons.FirstOrDefault(y =&gt; x.Equals(y.Beacon));
            if (beacon == null)
                this.Beacons.Add(new BeaconViewModel(x));
            else
            {
                beacon.Proximity = x.Proximity;
                beacon.LastSeen = DateTime.UtcNow;
            }
        }
    );

// more to cleanup
Observable
    .Interval(TimeSpan.FromSeconds(5))
    .ObserveOn(RxApp.MainThreadScheduler) // again, borring from RXUI
    .Synchronize(this.Beacons)
    .Subscribe(_ =&gt;
    {
        var maxAge = DateTimeOffset.UtcNow.Subtract(TimeSpan.FromSeconds(10));
        var tmp = this.Beacons.Where(x =&gt; x.LastSeen &lt; maxAge).ToList();
        foreach (var beacon in tmp)
        {
            this.Beacons.Remove(beacon);
        }
    });

public class BeaconViewModel : ReactiveObject
{
    public BeaconViewModel(Beacon beacon)
    {
        this.Beacon = beacon;
        this.Proximity = beacon.Proximity;
        this.LastSeen = DateTime.UtcNow;
    }


    public Beacon Beacon { get; }
    public ushort Major =&gt; this.Beacon.Major;
    public ushort Minor =&gt; this.Beacon.Minor;
    public string Identifier =&gt; $&quot;Major: {this.Major} - Minor: {this.Minor}&quot;;
    public DateTime LastSeen { get; set; }
    [Reactive] public Proximity Proximity { get; set; }
}
</code></pre>


</div>
<div class="tab__content">

<pre><code class="language-csharp">var scanner = ShinyHost.Resolve&lt;Shiny.Beacons.IBeaconRangingManager().CreateManagedScan();


// your viewmodel/view binding collection - note that you aren't managing it :)
public ObservableCollection&lt;ManagedBeacon&gt; Beacons =&gt; this.scanner.Beacons;

// start the scan
scanner.Start(new BeaconRegion(&quot;your id&quot;, &quot;your uuid&quot;), RxApp.MainThreadScheduler);


// and when you're ready to stop
scanner.Stop();
</code></pre>


</div>
</div>

<h2 id="in-closing">In Closing</h2>
<p>This article only scrapped the surface of the 2.0 upgrade.  There's more articles to come and the docs are shaping up nicely.  There are also other packages like NFC, Speech to Text, BLE Hosting, Sensors, and HTTP Transfers that all still exists.  They just didn't see any
huge feature updates in this release.</p>
<p>I want to thank my good friend <a href="https://twitter.com/DanJSiegel">Dan Siegel</a> of Prism fame for all of the help, testing, tooling, suggesting, blog articles, and poking (cough...nagging).  Shiny and the Xamarin community as a whole is a better place because of him.
His work on <a href="https://mobilebuildtools.com/">Mobile Build Tools</a> was also immensely helpful for the Shiny samples and integration tests.</p>
<p>The future of Shiny now begins to look towards app services which moves from device &amp; background servicing to truly solving real world business cases.  Some of the things I'm working on:</p>
<ul>
<li>GeoDispatch - Push + GPS for incident management scenarios</li>
<li>GPS Tags - like the airtags but with normal beacons and GPS</li>
<li>Trip Tracker - tracks your runs, walks, drives, etc in one easy to use API</li>
<li>OBD Communications - Talking to these things even with the Shiny BLE API is still a bit of work.  This is going to make it easy!</li>
</ul>
<p>I'm also still considering future platforms like WASM &amp; macOS, but we'll see how the ecosystem shapes up.  I also want to mention that I've been working with the MAUI team on integrations.  I'll have more to share later this year as it stabilizes.</p>
<p>As with all OSS, Shiny is always looking for help.  Head over to GitHub if you've got an issue to report, an enhancement idea, or if you just want to help out.</p>
<h2 id="links">LINKS</h2>
<ul>
<li><a href="https://shinyorg.github.io">Documentation</a>
</li>
<li><a href="https://github.com/shinyorg/shiny">Samples</a>
</li>
<li><a href="https://github.com/shinyorg/shiny/tree/master/samples">GitHub</a>
</li>
<li><a href="https://www.nuget.org/profiles/ShinyLib">NuGets</a>
</li>
</ul>

<hr />
<h1 style="text-align: center">Please use comments below for discussion about the implementation, not for support queries or issues you find. Please file <a href="https://github.com/shinyorg/shiny/issues/new/choose">issues here</a></h1>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    <!-- allan-ritchies-blog.disqus.com -->
    var disqus_shortname = 'allan-ritchies-blog'; // required: replace example with your forum shortname
    var disqus_identifier = 'shiny20';
    var disqus_title = 'Shiny 2.0 For Xamarin - Shinier Than Ever';
    var disqus_url = 'https://aritchie.github.io/posts/shiny20';
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>      </div>
    </div>
  </div>

  <hr>

  <!-- Footer -->
  <div id="footer" class="p-3 text-white" style="background: black">
    <div class="container-xl">
        <div class="row">
            <div class="offset-lg-2 col-12 col-lg-8">
                <div class="text-light text-center font-size-sm">
                    <a target="_NEWWINDOW" href="https://github.com/aritchie" class="text-light pr-2 mr-1"><i class="fab fa-github"></i> GitHub</a>
                    <a target="_NEWWINDOW" href="https://twitter.com/allanritchie911" class="text-light pr-2 mr-1"><i class="fab fa-twitter"></i> Twitter</a>
                    <a target="_NEWWINDOW" href="https://twitch.tv/allancritchie" class="text-light pr-2 mr-1"><i class="fab fa-twitch"></i> Twitch</a>
                    <a target="_NEWWINDOW" class="text-light font-weight-bold" href="https://github.com/sponsors/aritchie"><i class="fa fa-heart"></i> Support</a>
                </div>
                <div class="pt-2 font-size-sm text-muted text-center">
                    © 2021 Allan Ritchie
                </div>
            </div>
        </div>
    </div>
</div>



  <!-- Bootstrap core JavaScript -->
  <script src="/vendor/jquery/jquery.min.js"></script>
  <script src="/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134251257-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-134251257-1');
</script>


  

  <!-- Custom scripts for this template -->
  <script src="/js/clean-blog.js"></script>

</body>

</html>
