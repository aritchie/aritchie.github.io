<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title>Personal Blog of Allan Ritchie</title>
		<link>https://aritchie.github.io/</link>
		<description />
		<copyright>2021</copyright>
		<pubDate>Wed, 03 Mar 2021 19:15:38 GMT</pubDate>
		<lastBuildDate>Wed, 03 Mar 2021 19:15:38 GMT</lastBuildDate>
		<item>
			<title>Shiny 2.0 - Shinier Than Ever</title>
			<link>https://aritchie.github.io/posts/shiny20</link>
			<description>&lt;p&gt;Version 2.0 is months of work, hundreds of commits, and a lot of discovery around how to improve the end experience.  This release focused on improving the background experience
even more especially on Android.  Android is the source of great pain when it comes to backgrounding and especially around expectations that people
have (for instance, real time background GPS).  As such, Shiny now uses foreground services in most of these places.  As a developer using Shiny, this is completely
transparent change for you unless you want to customize the notification.&lt;/p&gt;</description>
			<enclosure url="https://aritchie.github.io/images/shiny_logo.png" length="0" type="image" />
			<guid>https://aritchie.github.io/posts/shiny20</guid>
			<pubDate>Fri, 12 Jun 2020 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="tldr"&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;Version 2.0 is months of work, hundreds of commits, and a lot of discovery around how to improve the end experience.  This release focused on improving the background experience
even more especially on Android.  Android is the source of great pain when it comes to backgrounding and especially around expectations that people
have (for instance, real time background GPS).  As such, Shiny now uses foreground services in most of these places.  As a developer using Shiny, this is completely
transparent change for you unless you want to customize the notification.&lt;/p&gt;
&lt;p&gt;Now that I'm done with the boring rant.  Let's talk about some of the cool new features&lt;/p&gt;
&lt;p&gt;The main topics&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Boilerplate Code&lt;/li&gt;
&lt;li&gt;BluetoothLE&lt;/li&gt;
&lt;li&gt;Push Notifications&lt;/li&gt;
&lt;li&gt;Local Notifications&lt;/li&gt;
&lt;li&gt;What's Next - App Services!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="death-to-boilerplate-code"&gt;Death to Boilerplate Code&lt;/h2&gt;
&lt;p&gt;This was the first source of support pain and issues that users had was usually missed (or wrong) setup.  In 2.0, I set out for how to remove this issue.  With the latest C#/.NET5 release,
source generators were released.  This allows for code to be injected in the places Shiny needed it.  To make things even more convenient for users, I can also wire up all of their
Xamarin Forms, Xamarin Essentials, and other 3rd party source code.&lt;/p&gt;
&lt;p&gt;To get an idea, here is a before and after showing both iOS and Android boilerplate&lt;/p&gt;
&lt;h3 id="before-no-code-gen"&gt;BEFORE (no code gen)&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Android App
[global::Android.App.ApplicationAttribute]
public partial class MainApplication : global::Android.App.Application
{
	public MainApplication(IntPtr handle, JniHandleOwnership transfer) : base(handle, transfer) {}

	public override void OnCreate()
	{
		this.ShinyOnCreate(new Samples.SampleStartup());
		global::Xamarin.Essentials.Platform.Init(this);
		base.OnCreate();
	}
}

// Android Activity
public partial class MainActivity
{
	protected override void OnCreate(Bundle savedInstanceState)
	{
		this.ShinyOnCreate();
		TabLayoutResource = Resource.Layout.Tabbar;
		ToolbarResource = Resource.Layout.Toolbar;
		base.OnCreate(savedInstanceState);
		global::Xamarin.Forms.Forms.Init(this, savedInstanceState);
		this.LoadApplication(new Samples.App());
	}

	protected override void OnNewIntent(Intent intent)
	{
		base.OnNewIntent(intent);
		this.ShinyOnNewIntent(intent);
	}

	protected override void OnActivityResult(int requestCode, Result resultCode, Intent data)
	{
		base.OnActivityResult(requestCode, resultCode, data);
		this.ShinyOnActivityResult(requestCode, resultCode, data);
	}
	public override void OnRequestPermissionsResult(int requestCode, string[] permissions, [GeneratedEnum] Permission[] grantResults)
	{
		base.OnRequestPermissionsResult(requestCode, permissions, grantResults);
		this.ShinyOnRequestPermissionsResult(requestCode, permissions, grantResults);
		global::Xamarin.Essentials.Platform.OnRequestPermissionsResult(requestCode, permissions, grantResults);
	}
}

// iOS AppDelegate - all features used
public partial class AppDelegate
{
	partial void OnPreFinishedLaunching(UIApplication app, NSDictionary options);
	partial void OnPostFinishedLaunching(UIApplication app, NSDictionary options);
	public override bool FinishedLaunching(UIApplication app, NSDictionary options)
	{
		this.ShinyFinishedLaunching(new Samples.SampleStartup());
		global::Xamarin.Forms.Forms.Init();
		this.LoadApplication(new Samples.App());
		return base.FinishedLaunching(app, options);
	}
	public override void RegisteredForRemoteNotifications(UIApplication application, NSData deviceToken) =&amp;gt; this.ShinyRegisteredForRemoteNotifications(deviceToken);
	public override void ReceivedRemoteNotification(UIApplication application, NSDictionary userInfo) =&amp;gt; this.ShinyDidReceiveRemoteNotification(userInfo, null);
	public override void DidReceiveRemoteNotification(UIApplication application, NSDictionary userInfo, Action&amp;lt;UIBackgroundFetchResult&amp;gt; completionHandler) =&amp;gt; this.ShinyDidReceiveRemoteNotification(userInfo, completionHandler);
	public override void FailedToRegisterForRemoteNotifications(UIApplication application, NSError error) =&amp;gt; this.ShinyFailedToRegisterForRemoteNotifications(error);
	public override void PerformFetch(UIApplication application, Action&amp;lt;UIBackgroundFetchResult&amp;gt; completionHandler) =&amp;gt; this.ShinyPerformFetch(completionHandler);
	public override void HandleEventsForBackgroundUrl(UIApplication application, string sessionIdentifier, Action completionHandler) =&amp;gt; this.ShinyHandleEventsForBackgroundUrl(sessionIdentifier, completionHandler);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="after"&gt;AFTER&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Android Application - you don't even have to make one
// Android Activity
public partial class MainActivity : Xamarin.Forms.Platform.Android.FormsAppCompatActivity
{
}

// iOS AppDelegate
[Register(&amp;quot;AppDelegate&amp;quot;)]
public partial class AppDelegate : Xamarin.Forms.Platform.iOS.FormsApplicationDelegate
{
}

[assembly: ShinyApplication(
    ShinyStartupTypeName = &amp;quot;Samples.SampleStartup&amp;quot;,
    XamarinFormsAppTypeName = &amp;quot;Samples.App&amp;quot;
)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To get this &amp;quot;voodoo&amp;quot; magic.  Simply install the Shiny nuget package.  It's new with 2.0 and add the attribute shown above in &amp;quot;after&amp;quot;.&lt;/p&gt;
&lt;h2 id="static-class-generation"&gt;Static Class Generation&lt;/h2&gt;
&lt;p&gt;There are a lot of users that don't like dependency injection.  I finally decided to bring the best of both worlds, one where I can live on my hill of DI and not code statics, and one where users could have static classes.&lt;/p&gt;
&lt;p&gt;The answer was again, source generation.  By simply adding the &amp;quot;Shiny&amp;quot; nuget package and adding [assembly: StaticClasses(&amp;quot;YourNamespace&amp;quot;)], the code generators will look through all of the Shiny libraries you have referenced in that project and
generate a pretty static class for you to use.  NO DI!&lt;/p&gt;
&lt;h2 id="notifications"&gt;Notifications&lt;/h2&gt;
&lt;p&gt;Notifications had to undergo some changes to make sure things like sounds worked and response actions from notifications were consistent across platforms, thus, channels were
created as to play ball properly with channels on Android and to a far lesser degree, categories on iOS.&lt;/p&gt;
&lt;p&gt;Channels are essentially configuration groups.  This provides equivalent functionality to what you find on Android 8+&lt;/p&gt;
&lt;p&gt;PHOTO OF ACTIONS&lt;/p&gt;
&lt;h2 id="push-notifications"&gt;Push Notifications&lt;/h2&gt;
&lt;p&gt;Since the mobile era began, I can't count on two hands how many push notification service providers I've seen come and go.  AppCenter, HockeyApp&lt;/p&gt;
&lt;p&gt;Currently, Shiny is working with Native, Google Firebase Messaging, and Azure Push Notification Hubs.&lt;/p&gt;
&lt;p&gt;Tag Support&lt;/p&gt;
&lt;h2 id="bluetooth-le"&gt;Bluetooth LE&lt;/h2&gt;
&lt;p&gt;I really went through all of the API calls this library had to offer.&lt;/p&gt;
&lt;p&gt;BLE is still firmly (and always will be) rooted in Reactive Extensions, but I wanted to make the APIs easier to consume for all users including myself.&lt;/p&gt;
&lt;p&gt;Managed Scans
Scanning was riddled with potential issues&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;maintaining a list of unique peripherals while still watching things like the RSSI and&lt;/li&gt;
&lt;li&gt;synchronizing list updates to your UI&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Managed Peripheral
The problem with traditional peripheral managed is that with every connection, you had to rescan for all of the services and characteristics you had.  You also had to restore any notifications you had.
This was painful&lt;/p&gt;
&lt;h2 id="app-services"&gt;App Services&lt;/h2&gt;
&lt;p&gt;The Shiny project has focused mainly on device hardware and backgrounding.  Over the past couple of years, I've seen so many issues bringing the &amp;quot;pieces&amp;quot; together.  With App Services,
I'm now setting out to tackle raw business issues by bringing Shiny services together and providing a very easy to use API to accomplish this.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Azure Notification Hubs&lt;/li&gt;
&lt;li&gt;Firebase Messaging&lt;/li&gt;
&lt;li&gt;Straight Native&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var result = await PushManager.RequestAccess();
if (result.Status == Shiny.AccessState.Available) 
{
    result.RegistrationToken;
}

// foreground
PushManager.WhenReceived().Subscribe(data =&amp;gt; {

});

// background
public class MyPushDelegate : Shiny.Push.IPushDelegate
{

}


// configuring it and switch between them - 1 line of code!

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="application-services"&gt;Application Services&lt;/h1&gt;
&lt;p&gt;Shiny's first purpose in life was to make cross platform device &amp;amp; background services easy, but it was never going to stop there.  I'm now starting to work on services to make scenarios easy.  Here are the first two Shiny modules to follow this plan&lt;/p&gt;
&lt;h2 id="obd"&gt;OBD&lt;/h2&gt;
&lt;h2 id="shiny.locations.sync"&gt;Shiny.Locations.Sync&lt;/h2&gt;
&lt;p&gt;Sync geofence and GPS events to your backend using a consistent and aggressive practices to ensure this data calls home ASAP&lt;/p&gt;
&lt;h2 id="shiny.mediasync"&gt;Shiny.MediaSync&lt;/h2&gt;
&lt;p&gt;This will scan and upload photos, videos, &amp;amp; audio from your Android &amp;amp; iOS media gallery&lt;/p&gt;
&lt;h2 id="shiny.triptracker"&gt;Shiny.TripTracker&lt;/h2&gt;
&lt;p&gt;Continuing the theme of app services and making the hard tasks easy - trip tracker will record trips for walks, runs, cycling, and automotive.  It uses a combination of GPS and motion activity to record trips.&lt;/p&gt;
&lt;h2 id="bluetoothle-refit-client"&gt;BluetoothLE &amp;quot;Refit&amp;quot; Client&lt;/h2&gt;
&lt;p&gt;the one mechanism that people seem to keep coming back to me about.  The work has begun.  There will be 2 packages, Shiny.BluetoothLE and Shiny.BluetoothLE.Hosting.  I'm looking to simplify the APIs while still making them as powerful as ever.  There is also a scope of work to have the client work similar to &lt;a href="https://github.com/reactiveui/refit"&gt;Refit&lt;/a&gt; and having the GATT host look like SignalR hubs.  This is still in a very early proof-of-concept.&lt;/p&gt;
&lt;h2 id="bluetoothle-signalr-hosting"&gt;BluetoothLE SignalR Hosting&lt;/h2&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Startup Tasks, Modules, and Stateful Delegates - Shiny Style</title>
			<link>https://aritchie.github.io/posts/shiny-di</link>
			<description>&lt;p&gt;Shiny isn't all about backgrounding, DI, RX, and all of that cool stuff.  It actually provides a ton of utility functions as well.&lt;/p&gt;</description>
			<enclosure url="https://aritchie.github.io/images/toronto_pan.jpg" length="0" type="image" />
			<guid>https://aritchie.github.io/posts/shiny-di</guid>
			<pubDate>Mon, 01 Jul 2019 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="this-article-applies-to-all-versions-of-shiny"&gt;THIS ARTICLE APPLIES TO ALL VERSIONS OF SHINY&lt;/h1&gt;
&lt;p&gt;Shiny isn't all about backgrounding, DI, RX, and all of that cool stuff.  It actually provides a ton of utility functions as well.&lt;/p&gt;
&lt;p&gt;I love Autofac and a lot of the functions it has.  It really is a great DI framework though is known for being a tad on the slow side.  With Shiny, I went with Microsoft.Extensions.DependencyInjection as the DI platform of choice.  It is fast, has "enough" features, built on a great set of abstractions, and has monolith company backing it.  However, it is no Autofac in terms of features - so I wanted to carry a few of them forward.  Namely, modules and startables.  I've also added a very useful feature in stateful delegates which is my personal favorite!  I'll explain what this in this article as well.&lt;/p&gt;
&lt;h2 id="modules"&gt;Modules&lt;/h2&gt;
&lt;p&gt;Inversion of Control (IoC) acts as the basic building blocks of your application.  However, as your application grows, registering all of these components within a single point of entry can lead to a fat file.&lt;/p&gt;
&lt;p&gt;Modules help by alleviating this.  They are used to help decouple your libraries, so that you can bundle up a set of related components behind a neatly wrapped package to simplify deployment and management of your application. Modules can also help by entangling bits of configuration code internal to library itself instead of literating your startup file with all of these additional flags.&lt;/p&gt;
&lt;p&gt;Below is an example of the data registration module that I use within one of my sample apps &lt;a href="https://github.com/aritchie/stream-todo"&gt;Shiny TODOs&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System;
using Microsoft.Extensions.DependencyInjection;
using Refit;
using Shiny;
using Shiny.Jobs;


namespace Todo.Data
{
    public class DataModule : ShinyModule
    {
        public override void Register(IServiceCollection services)
        {
            services.AddSingleton(_ =&amp;gt; RestService.For&amp;lt;IApiClient&amp;gt;(Constants.BaseApiUri));
            services.AddSingleton&amp;lt;TodoSqliteConnection&amp;gt;();
            services.AddSingleton&amp;lt;IDataService, SqliteDataService&amp;gt;();

            services.RegisterJob(new JobInfo
            {
                Identifier = nameof(SyncJob),
                Type = typeof(SyncJob),
                BatteryNotLow = true,
                RequiredInternetAccess = InternetAccess.Any
            });
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, you can see I'm injecting a SQLite connection, a data service provider, a remote API, and even registering a background job to synchronize the data to/from the server.  You may ask why this is good?  Well - the SQLite connection, api client, and job are all outside of my domain - meaning, the application as a whole, really doesn't have knowledge of their existence (nor should they).  They are just pieces of work that this particular portion of the app needs to do its job without effecting things around it.&lt;/p&gt;
&lt;p&gt;All that is left is to wire this into your Shiny startup (make sure you reference your library if it is a separate project).&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Shiny;


namespace Todo
{
    public class ShinyStartup : ShinyStartup
    {
        public override void ConfigureServices(IServiceCollection services)
        {
            services.RegisterModule&amp;lt;Todo.Data.DataModule&amp;gt;();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="startup-tasks"&gt;Startup Tasks&lt;/h2&gt;
&lt;p&gt;The IStartable/AutoActivate in Autofac is awesome as long as you used it in a smart way.  This concept does not exist in Microsoft's DI extensions.  These startables are something I use fairly frequently in my applications for various background tasks.&lt;/p&gt;
&lt;p&gt;Startup tasks in Shiny are similar to IStartable's in Autofac if you've ever used them.  Since Shiny is essentially DI agnostic, I wanted this feature to be available to all things DI.&lt;/p&gt;
&lt;h3 id="how-do-startup-tasks-differ-from-a-job"&gt;How do startup tasks differ from a job?&lt;/h3&gt;
&lt;p&gt;This is a great &amp;amp; likely common question I suspect, but also very easy to answer.  Startup tasks happen at the point of the container build when all of your services are ready to go.  The difference is that these tasks don't run in the background.  What they offer is a way of hooking up general pipeline logic within your app.  WARNING: These startup tasks should execute very quickly as you will pay a startup cost.  Also note, startup tasks are NOT async.  There are many, many, many reasons for this.  They are designed to hook up internal events and maybe wire up some necessary infrastructure... nothing more!&lt;/p&gt;
&lt;h3 id="what-would-i-do-with-one-of-these"&gt;What would I do with one of these?&lt;/h3&gt;
&lt;p&gt;I often like to wire up my auth service that has a "SignOut" event.  When that signout event fires, I may delete a local database, clear all notifications, etc.&lt;/p&gt;
&lt;h3 id="how-do-i-make-one"&gt;How do I make one?&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class YourStartupTask : Shiny.IShinyStartupTask
{
    public YourStartupTask()
    {
        // you can inject just like everything else in shiny
    }

    public void Start()
    {
        // do your hooking of events and init stuff here :)
    }
}

// in your shiny startup
public void ConfigureServices(IServiceCollection builder)
{
    builder.RegisterStartupTask&amp;lt;YourStartupTask&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="stateful-delegates"&gt;Stateful Delegates&lt;/h2&gt;
&lt;p&gt;My good friend Dan Siegel had been asking for something to help him manage GPS state and even used a decent trick with something that was already built into Shiny - the strong typed settings library.  Take a look at this &lt;a href="https://aritchie.github.io/shinysettings"&gt;article&lt;/a&gt; to see what's going on there.  I decided to build this into all event delegates that Shiny uses. All you have to do is make your delegate inherit from INotifyPropertyChanged, make your "stateful" properties public get/set, and raise notifications on their state changes.  While the sample below can be accomplished easier otherways, as the stateful properties become larger, this pattern begins to pay off - so I hope you're as excited about this as I am!!&lt;/p&gt;
&lt;p&gt;NOTE: this does not work on jobs.  Jobs have their own special type of state management using the JobInfo argument in Run.  This may change in the future.&lt;/p&gt;
&lt;p&gt;Here's a great example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System;
using System.Threading.Tasks;
using Samples.Models;
using Shiny.Notifications;
using Shiny.Locations;


namespace Samples.ShinyDelegates
{
    public class YourGeofenceDelegate : Shiny.NotifyPropertyChanged, Shiny.Locations.IGeofenceDelegate
    {
        readonly INotificationManager notifications;
        public YourGeofenceDelegate(INotificationManager notifications)
        {
            this.notifications = notifications;
        }


        bool welcomed;
        public bool HasAlreadyBeenWelcomed
        {
            get =&amp;gt; welcomed;
            set =&amp;gt; Set(ref welcomed, value);
        }


        public async Task OnStatusChanged(GeofenceState newStatus, GeofenceRegion region)
        {
            if (!this.HasAlreadyBeenWelcomed)
            {
                await this.notifications.Send("WELCOME", "Houston welcomes you the first ever Xamarin Developer Summit"); // yes, you can see where this was used :)
                this.HasAlreadyBeenWelcomed = true;
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So next time this guy fires, whether from the background, reboot, etc - that state will be remembered.  This is pretty epic in my opinion!&lt;/p&gt;
&lt;p&gt;Note, I had considered serializing &amp;amp; deserializing stateful properties (get/set) per delegate trigger, but with things like GPS that can fire rapidly, this may introduce performance issues.  The advantage to serializing/deserializing per run - is that you don't need a viewmodelish type setup.  Just plain old-C# public get/sets.&lt;/p&gt;
&lt;h2 id="in-closing"&gt;In Closing&lt;/h2&gt;
&lt;p&gt;Modules &amp;amp; startup tasks provide a great way to modulizing your application and providing a rich set of wiring services together without coupling them within your normal application logic (ie. ViewModels).&lt;/p&gt;
&lt;h2 id="links"&gt;Links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/shinyorg/shiny"&gt;Source Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/shinyorg/shiny/samples"&gt;Samples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://shinylib.net"&gt;Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/Shiny.Core/"&gt;&lt;img src="https://img.shields.io/nuget/v/Shiny.Core.svg?maxAge=2592000" alt="NuGet"&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Beacons - Shiny Style</title>
			<link>https://aritchie.github.io/posts/shiny-beacons</link>
			<description>&lt;p&gt;Beacons are low powered IoT devices that emit a signal over Bluetooth advertising that contains a specific (and very small piece of data) that is like an address.  You attach that address to a "location" of some type.  They are like an invisible light house.  If you have a device that can "see" those signals, you can find out how close you are to it.&lt;/p&gt;</description>
			<enclosure url="https://aritchie.github.io/images/shiny_beacons.png" length="0" type="image" />
			<guid>https://aritchie.github.io/posts/shiny-beacons</guid>
			<pubDate>Mon, 10 Jun 2019 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="what-are-beacons"&gt;What are Beacons&lt;/h2&gt;
&lt;p&gt;Beacons are low powered IoT devices that emit a signal over Bluetooth advertising that contains a specific (and very small piece of data) that is like an address.  You attach that address to a "location" of some type.  They are like an invisible light house.  If you have a device that can "see" those signals, you can find out how close you are to it.&lt;/p&gt;
&lt;p&gt;Some beacons include sensors like temperature, accelerometers, ambient light, pressure, and more.  Head over to &lt;a href="https://estimote.com/products/"&gt;Estimote&lt;/a&gt; to take a look.  These guys are essentially the Rolls Royce of the beacon industry.&lt;/p&gt;
&lt;p&gt;Beacons from a software perspective actually come in several flavours/protocols.  The main one in practice is iBeacon which is a protocol created by Apple.  There is a beacon protocol by Google called Eddystone. Eddystone doesn't seem to have caught on like iBeacons did.  Eddystone is currently not a supported with Shiny.&lt;/p&gt;
&lt;h2 id="terminology"&gt;Terminology&lt;/h2&gt;
&lt;p&gt;Beacons are riddled with terms and acronyms.  Let me hopefully clear up the ones that matter.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Identifier&lt;/strong&gt; - this is a string, for you to set how you see fit (within reasons obviously)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UUID (Universally Unique Identifier)&lt;/strong&gt; - This is a GUID in .NET terms.  You could equate this to the city where you live&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Major&lt;/strong&gt; - This is a ushort (uint16).  This would equate to the street on which you live&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Minor&lt;/strong&gt; - This is also a ushort (uint16).  This would equate to your street number.  Thereby, giving you the greatest precision in identification.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ranging&lt;/strong&gt; - Refers to scanning for all beacons within a certain address range.  You can see any and all beacons within your filter parameters as well as how close you are to it.  Think &lt;a href="https://ghostbusters.fandom.com/wiki/P.K.E._Meter"&gt;GhostBuster PKE Meter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Monitoring&lt;/strong&gt; - The art of scanning for a "filtered" set of beacon address in the background.  You don't know how close you are to the target in this mode, only if you are entering the region or leaving it.  If you watch the show "Chernobyl" on HBO - think the equivalent being the dosimeters on the belts of these guys (the clicking - you are in the bad zone) - &lt;a href="https://www.youtube.com/watch?v=uXafEIdkx6c"&gt;Watch Here&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;iOS&lt;/em&gt; - You can monitor 20 beacons (this includes any geofences your app uses as well, so careful here) max&lt;/li&gt;
&lt;li&gt;&lt;em&gt;UWP/Android&lt;/em&gt; - Technically, there is no limit here, but I would stick to 20 as well.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="working-with-beacons-shiny-style"&gt;Working with Beacons - Shiny Style&lt;/h2&gt;
&lt;p&gt;Shiny provides the first fully managed beacon implementation for Android &amp;amp; UWP.  It's reach is only limited currently by the reach of Shiny.BluetoothLE.  For iOS, it simply makes use of the iOS API because Apple hijacks all beacon packets (you can't touch them with raw BLE).&lt;/p&gt;
&lt;h3 id="getting-started"&gt;Getting Started&lt;/h3&gt;
&lt;p&gt;Again, to save some time - the best place to go for getting the initial setup with shiny is &lt;a href="https://aritchie.github.io/introducingshiny"&gt;RIGHT HERE&lt;/a&gt;.  For this article, I'm going to register &lt;a href="https://www.nuget.org/packages/Shiny.Beacons/"&gt;Shiny.Beacons&lt;/a&gt; and &lt;a href="https://www.nuget.org/packages/Shiny.Notifications/"&gt;Shiny.Notifications&lt;/a&gt; for backgrounding in the second part of this post under monitoring.&lt;/p&gt;
&lt;h3 id="android"&gt;Android&lt;/h3&gt;
&lt;p&gt;Other than the normal Android setup for Shiny, you need to add the following to your manifest.xml - we'll need a few bluetooth permissions here.  Bluetooth on Android requires location permissions as well as Bluetooth since Android 6 due to the use of beacons.&lt;/p&gt;
&lt;p&gt;Let's get started with the traditional OS setup (yes UWP is supported, but is left out for now)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&amp;gt;
&amp;lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&amp;gt;

&amp;lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&amp;gt;
&amp;lt;uses-permission android:name="android.permission.BLUETOOTH" /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="ios"&gt;iOS&lt;/h3&gt;
&lt;p&gt;Again, same typical iOS initialization.  Just add the following to your info.plist.  The UIBackgroundModes is required for Beacons since they are location context even though they are bluetooth devices - so just like &lt;a href="https://aritchie.github.io/shiny-geofencing"&gt;Geofences&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;key&amp;gt;NSLocationAlwaysUsageDescription&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;Your message&amp;lt;/string&amp;gt;
&amp;lt;key&amp;gt;NSLocationAlwaysAndWhenInUseUsageDescription&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;Your message&amp;lt;/string&amp;gt;
&amp;lt;key&amp;gt;NSLocationWhenInUseUsageDescription&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;Your message&amp;lt;/string&amp;gt;

&amp;lt;key&amp;gt;UIBackgroundModes&amp;lt;/key&amp;gt;
&amp;lt;array&amp;gt;
    &amp;lt;string&amp;gt;location&amp;lt;/string&amp;gt;
&amp;lt;/array&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="in-your-shared-code"&gt;In Your Shared Code&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System;
using Shiny;
using Shiny.Beacons;
using Shiny.Notifications;
using Microsoft.Extensions.DependencyInjection;


namespace YourNamespace
{
    public class SampleStartup : ShinyStartup
    {
        public override void ConfigureServices(IServiceCollection builder)
        {
            // only necessary for the monitoring - for ranging only you can use UseBeacons()
            builder.UseBeaconRanging&amp;lt;MyBeaconDelegate&amp;gt;();
            builder.UseNotifications();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="ranging"&gt;Ranging&lt;/h3&gt;
&lt;p&gt;Ranging is particularily easy - you can do this right in your viewmodel.  With ranging, you are given the specific beacon with its proximity.  You still have to set a beacon region to monitor that filters by at least your global UUID.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
public class YourViewModel
{
    IDisposable scanSub;


    public YourViewModel()
    {
        this.Start = new Command(() =&amp;gt;
        {
            this.scanSub = Shiny
                .ShinyHost
                .Resolve&amp;lt;IBeaconManager&amp;gt;()
                .WhenRanged(new BeaconRegion(YourUuid))
                .Subscribe(x =&amp;gt; Device.BeginInvokeOnMainThread(() =&amp;gt;                
                    this.Beacons.Add(x)
                ))
        });

        this.Stop = new Command(() =&amp;gt; this.scanSub?.Dispose());
    }


    public ICommand Start { get; }
    public ICommand Stop { get; }
    public IList&amp;lt;Beacon&amp;gt; Beacons { get; private set; }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="monitoring"&gt;Monitoring&lt;/h3&gt;
&lt;p&gt;With monitoring, you aren't given the specific beacon or how close the phone is to the beacon in terms of proximity.  You are basically handed back the filter you used.  This is to protect the privacy of the user (which I actually agree with).  This is a pretty easy task to perform on iOS, but brutally painful to do in Android.  Shiny makes this an absolutely delightful to do.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System;
using System.Threading.Tasks;
using Samples.Models;
using Shiny.Beacons;
using Shiny.Notifications;


namespace YourNamespace
{
    public class MyBeaconDelegate : IBeaconDelegate
    {
        readonly INotificationManager notifications;
        public MyBeaconDelegate(INotificationManager notifications) 
        {
            this.notifications = notifications;
        }


        public async Task OnStatusChanged(BeaconRegionState newStatus, BeaconRegion region)
        {
            await this.notifications.Send(
                $"Beacon Region {newStatus}",
                $"{region.Identifier} - {region.Uuid}/{region.Major}/{region.Minor}"
            );
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="in-closing"&gt;In Closing&lt;/h2&gt;
&lt;p&gt;Give Beacons a try - they are great for a variety of business applications from marketing to employee management&lt;/p&gt;
&lt;h2 id="links"&gt;Links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://aritchie.github.io/introducingshiny"&gt;Initial Shiny Setup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/shinyorg/shinysamples/tree/master/Samples/Beacons"&gt;Samples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://shinylib.net"&gt;Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Shiny.Core - &lt;a href="https://www.nuget.org/packages/Shiny.Core/"&gt;&lt;img src="https://img.shields.io/nuget/v/Shiny.Core.svg?maxAge=2592000" alt="NuGet"&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Shiny.Beacons - &lt;a href="https://www.nuget.org/packages/Shiny.Beacons/"&gt;&lt;img src="https://img.shields.io/nuget/v/Shiny.Beacons.svg?maxAge=2592000" alt="NuGet"&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Shiny.Notifications - &lt;a href="https://www.nuget.org/packages/Shiny.Notifications/"&gt;&lt;img src="https://img.shields.io/nuget/v/Shiny.Notifications.svg?maxAge=2592000" alt="NuGet"&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://estimote.com/products/"&gt;Estimote Beacons&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Geofencing with a Pinch of Notifications - Shiny Style</title>
			<link>https://aritchie.github.io/posts/shiny-geofencing</link>
			<description>&lt;p&gt;GPS &amp;amp; Geofencing is a common need for mobile and IoT platforms alike.  However, mobile platforms with backgrounding in this area are always painful and that is being nice.  We've tried several plugins over the years, but they have all some sort of pain point.  Shiny aims to solve all of these as it provides a lot of base infrastructure to make things... shiny ;)&lt;/p&gt;</description>
			<enclosure url="https://aritchie.github.io/images/toronto_pan.jpg" length="0" type="image" />
			<guid>https://aritchie.github.io/posts/shiny-geofencing</guid>
			<pubDate>Tue, 21 May 2019 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="this-article-has-been-updated-to-shiny-2.0"&gt;THIS ARTICLE HAS BEEN UPDATED TO SHINY 2.0&lt;/h1&gt;
&lt;p&gt;GPS &amp;amp; Geofencing is a common need for mobile and IoT platforms alike.  However, mobile platforms with backgrounding in this area are always painful and that is being nice.  We've tried several plugins over the years, but they have all some sort of pain point.  Shiny aims to solve all of these as it provides a lot of base infrastructure to make things... shiny ;)&lt;/p&gt;
&lt;p&gt;We'll talk about GPS in a future article.  In this article, we'll focus on the geofencing and add in some notifications to make things awesome!&lt;/p&gt;
&lt;h2 id="what-are-geofences"&gt;What Are Geofences?&lt;/h2&gt;
&lt;p&gt;Geofencing is a location-based virtual boundary that uses GPS.  When you enter or exit this boundary, an event is executed in your application code.  A good example of this is a user coming close to your store and triggering a local notification - "Hey Peoples - come buy some stuff.  I'll make a deal you can't refuse".  When the user leaves the area "We're so sorry to see you leave.  Come back again and I'll give you 99% off with this magic code".  It's beautiful.... can be annoying, but if you do it right - you can create a good conversion opportunity.&lt;/p&gt;
&lt;h2 id="geofencing-why"&gt;Geofencing - Why?&lt;/h2&gt;
&lt;p&gt;Geofencing is very efficient on battery for the mobile operating systems.  One of the pitfalls is that it isn't exact in terms of fire times.  Sometimes it can take a couple of minutes before the event is actually triggered.  I often get asked why use a geofence over raw GPS.  The explanation I use is, are you in the mall or not - if you are in the mall, you likely won't have a good GPS signal either.  The calculation for determining the circular area of a geofence is also not 2 lines of code if you need to do the effort yourself using raw GPS.  Geofences are good for when you enter and exit a particular area, GPS is better for real time "where are you".&lt;/p&gt;
&lt;h2 id="pitfalls"&gt;Pitfalls&lt;/h2&gt;
&lt;p&gt;I've also seen a number of "gone bad" geofence routines.  This one implementation tried to register over 300 geofences at startup.... so ya... don't do that.  In fact, iOS limits you to 20 and Android caps it at 60.  You may think "wow that is limiting", but really - it isn't.  If you can't get the job done in 20 geofence registrations, honestly, in my opinion - you're doing something wrong.  I generally set a geofence on the center of a structure/area that I'm interested in and set a circular distance of 200 meters.  This is the perfect balance between battery and quick OS response time in my experience.&lt;/p&gt;
&lt;h2 id="making-it-happen-with-shiny"&gt;Making It Happen With Shiny&lt;/h2&gt;
&lt;p&gt;Do all of your normal Shiny setup - you can read my &lt;a href="https://aritchie.github.io/introducingshiny"&gt;Introducing Shiny&lt;/a&gt; to get going on the general setup stuff.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.nuget.org/packages/Shiny.Locations/"&gt;Shiny.Locations&lt;/a&gt; comes as a separate nuget package, but provides functionality for GPS &amp;amp; Geofencing.&lt;br&gt;
You'll also want to pickup &lt;a href="https://www.nuget.org/packages/Shiny.Notifications/"&gt;Shiny.Notifications&lt;/a&gt; to complete the sample in this article.&lt;/p&gt;
&lt;h3 id="in-your-shared-code"&gt;In Your Shared code&lt;/h3&gt;
&lt;p&gt;First, let's create our geofence delegate.  This is the guy that catches those events in the background.  As with all delegates in Shiny, you can inject your own services as long as they are registered with the Shiny container in your startup file.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Shiny.Locations;

namespace MyNamespace
{
    public class MyGeofenceDelegate : IGeofenceDelegate
    {
        readonly INotificationManager notifications;

        public MyGeofenceDelegate(INotificationManager notifications)
        {
            this.notifications = notifications;
        }


        public async Task OnStatusChanged(GeofenceState newStatus, GeofenceRegion region)
        {
            if (newState == GeofenceState.Entered)
            {
                await this.notifications.Send(new Notification 
                { 
                    Title = "WELCOME!",
                    Message = "It is good to have you back " + region.Identifier 
                });
            }
            else 
            {
                await this.notifications.Send(new Notification 
                { 
                    Title = "GOODBYE!", 
                    Message = "You will be missed at " + region.Identifier
                });
            }
        } 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, let's hook this guy up to Shiny, so we can get everything running&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System;
using Shiny;
using Shiny.Locations;
using Shiny.Notifications;
using Microsoft.Extensions.DependencyInjection;


public class SampleStartup : ShinyStartup
{
    public override void ConfigureServices(IServiceCollection builder)
    {
        builder.UseGeofencing&amp;lt;MyGeofenceDelegate&amp;gt;();
        builder.UseNotifications(true);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="ios"&gt;iOS&lt;/h3&gt;
&lt;p&gt;Only iOS requires a bit of extra configuration.  Just add the following to your info.plist.  The UIBackgroundModes is required for geofencing.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;key&amp;gt;NSLocationAlwaysUsageDescription&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;Your message&amp;lt;/string&amp;gt;
&amp;lt;key&amp;gt;NSLocationAlwaysAndWhenInUseUsageDescription&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;Your message&amp;lt;/string&amp;gt;
&amp;lt;key&amp;gt;NSLocationWhenInUseUsageDescription&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;Your message&amp;lt;/string&amp;gt;

&amp;lt;key&amp;gt;UIBackgroundModes&amp;lt;/key&amp;gt;
&amp;lt;array&amp;gt;
    &amp;lt;string&amp;gt;location&amp;lt;/string&amp;gt;
&amp;lt;/array&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="registering-an-actual-geofence"&gt;Registering an actual Geofence&lt;/h2&gt;
&lt;p&gt;Your viewmodel is the best place to register a geofence.&lt;/p&gt;
&lt;p&gt;Please note that while registering a geofence will request the necessary user permissions through the OS, if the user declines the necessary permission, the method will toss an exception.  It is a good practice to use IGeofenceManager.RequestAccess to know the state of things yourself.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Shiny;
using Shiny.Locations;
using Shiny.Notifications;


public class YourViewModel
{
    public YourViewModel()
    {
        // shiny doesn't usually manage your viewmodels, so we'll do this for now
        var geofences = ShinyHost.Resolve&amp;lt;IGeofenceManager&amp;gt;();
        var notifications = ShinyHost.Resolve&amp;lt;INotificationManager&amp;gt;();

        Register = new Command(async () =&amp;gt; 
        {
            // this is really only required on iOS, but do it to be safe
            var access = await notifications.RequestAccess();
            if (access == AccessState.Available)
            {
                await this.geofences.StartMonitoring(new GeofenceRegion(
                    "CN Tower - Toronto, Canada",
                    new Position(43.6425662, -79.3892508),
                    Distance.FromMeters(200)
                )
                {
                    NotifyOnEntry = true,
                    NotifyOnExit = true,
                    SingleUse = false
                });
            }
        });
    }

    public ICommand Register { get; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="in-closing"&gt;In Closing&lt;/h2&gt;
&lt;p&gt;Geofencing + Notifications is a powerful combination.  Hopefully, Shiny helps make this combo easy for you!&lt;/p&gt;
&lt;h2 id="links"&gt;Links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://aritchie.github.io/introducingshiny"&gt;Initial Shiny Setup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/shinyorg/shiny"&gt;Source Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/shinyorg/shinysamples"&gt;Samples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://shinylib.net"&gt;Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Shiny.Core - &lt;a href="https://www.nuget.org/packages/Shiny.Core/"&gt;&lt;img src="https://img.shields.io/nuget/v/Shiny.Core.svg?maxAge=2592000" alt="NuGet"&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Shiny.Locations - &lt;a href="https://www.nuget.org/packages/Shiny.Locations/"&gt;&lt;img src="https://img.shields.io/nuget/v/Shiny.Locations.svg?maxAge=2592000" alt="NuGet"&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Shiny.Notifications - &lt;a href="https://www.nuget.org/packages/Shiny.Notifications/"&gt;&lt;img src="https://img.shields.io/nuget/v/Shiny.Notifications.svg?maxAge=2592000" alt="NuGet"&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Settings in a New Light - Shiny Style</title>
			<link>https://aritchie.github.io/posts/shinysettings</link>
			<description>&lt;p&gt;I know - Preferences &amp;amp; Settings are a dime a dozen these days, but I'm such a big advocated of decoupled software that I had to do things differently.  With Shiny, I had a chance to move one of the features that I loved from my ACR Settings plugin over and give it a good home in a DI universe of awesome!&lt;/p&gt;</description>
			<enclosure url="https://aritchie.github.io/images/shiny_logo.png" length="0" type="image" />
			<guid>https://aritchie.github.io/posts/shinysettings</guid>
			<pubDate>Fri, 03 May 2019 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="this-article-applies-to-all-versions-of-shiny"&gt;THIS ARTICLE APPLIES TO ALL VERSIONS OF SHINY&lt;/h1&gt;
&lt;p&gt;I know - Preferences &amp;amp; Settings are a dime a dozen these days, but I'm such a big advocated of decoupled software that I had to do things differently.  With Shiny, I had a chance to move one of the features that I loved from my ACR Settings plugin over and give it a good home in a DI universe of awesome!&lt;/p&gt;
&lt;p&gt;You've probably seen code similar to this before:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
public static class AppSettings
{
    public static string ApiBaseUri
    {
        get =&amp;gt; Settings.Get(&amp;quot;ApiBaseUri&amp;quot;);
        set =&amp;gt; Settings.Set(&amp;quot;ApiBaseUri&amp;quot;, value);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="why-is-this-not-ideal"&gt;Why is this not ideal?&lt;/h3&gt;
&lt;p&gt;Several reasons&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is not a testable piece of code - not that settings usually have to be testable, but they are often used in tests&lt;/li&gt;
&lt;li&gt;It creates some coupling (yes we can get around this though)&lt;/li&gt;
&lt;li&gt;It uses some boilerplate code&lt;/li&gt;
&lt;li&gt;It isn't necessarily fun to wire through your app&lt;/li&gt;
&lt;li&gt;You can't react to changes in your settings&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="settings-in-a-different-light"&gt;Settings in a different light&lt;/h3&gt;
&lt;p&gt;Often people associate the INotifyPropertyChanged interface the ViewModel interface.  It is, but it can be used for many other cool things.  Let's look at this in a different way:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class AppSettings : Shiny.NotifyPropertyChanged
{
    public AppSettings()
    {
        // values set here are like defaults and not pushed settings 
        // they are overwritten by the settings binding if they were set
        this.RememberText = &amp;quot;Hello&amp;quot;; 
    }


    string rememberText;
    public string RememberText 
    { 
        get =&amp;gt; this.rememberText
        set =&amp;gt; this.Set(ref this.rememberText, value);
    }


    bool isEnabled;
    public bool IsEnabled
    { 
        get =&amp;gt; this.isEnabled;
        set =&amp;gt; this.Set(ref this.isEnabled, value);
    }


    DateTime? lastUpdated;
    public DateTime? LastUpdated 
    { 
        get =&amp;gt; this.lastUpdated;
        private set =&amp;gt; this.Set(ref this.lastUpdated, value);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, you can definitely argue that viewmodels contain their own set of boilerplate, but we've got so many tools to take care of things like this now a days such as ReactiveUI.Fody &amp;amp; PropertyChanged.Fody courtesy of Simon Cropp!&lt;/p&gt;
&lt;h3 id="messaging-in-a-new-reactive-light"&gt;Messaging in a new REACTIVE light:&lt;/h3&gt;
&lt;p&gt;Using the AppSettings class above, let's set that LastUpdated according to changes in the Remember Me&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
// adding to the constructor above
public AppSettings()
{
    // whenever a property changes, update the date (and remember it to)
    this.WhenAnyProperty(x =&amp;gt; x.IsEnabled).Subscribe(_ =&amp;gt; this.LastUpdated = DateTime.Now);
    this.WhenAnyProperty(x =&amp;gt; x.RememberText).Subscribe(_ =&amp;gt; this.LastUpdated = DateTime.Now);
}


// to register this as a service with Shiny - add the following to your Startup

public class MyStartup : Shiny.ShinyStartup
{
    public override void ConfigureServices(IServiceCollection services)
    {
        services.AddSingleton&amp;lt;AppSettings&amp;gt;();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That magical little method WhenAnyProperty is from a bunch of RX addons with Shiny.Core.&lt;/p&gt;
&lt;h3 id="what-about-doing-this-on-my-viewmodel"&gt;What about doing this on my ViewModel?&lt;/h3&gt;
&lt;p&gt;Sure, just make sure to unbind the ViewModel from settings when it is going away - Below is an example using Prism:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class MyViewModel : Prism.Mvvm.BindableBase, Prism.AppModel.IPageLifecycleAware
{
    readonly ISettings settings;


    public MyViewModel(ISettings settings)
    {
        this.settings = settings;
    }


    public void OnAppearing()
    {
        settings.Bind(this);
    }


    public void OnDisappearing()
    {
        settings.UnBind(this);
    }



    string rememberText;
    public string RememberText 
    { 
        get =&amp;gt; this.rememberText
        set =&amp;gt; this.SetProperty(ref this.rememberText, value);
    }


    bool isEnabled;
    public bool IsEnabled
    { 
        get =&amp;gt; this.isEnabled;
        set =&amp;gt; this.SetProperty(ref this.isEnabled, value);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="closing-thoughts"&gt;Closing Thoughts&lt;/h2&gt;
&lt;p&gt;Pretty epic right!?  This can serve in a bunch of capacities - you can use it as a good global store that you can monitor for changes (ie. Message Bus).   Give it a try - give us feedback - and may all your apps be Shiny!&lt;/p&gt;
&lt;h2 id="links"&gt;Links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/shinyorg/shiny"&gt;Source Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/shinyorg/tree/master/samples"&gt;Samples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://shinylib.net"&gt;Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/Shiny.Core/"&gt;&lt;img src="https://img.shields.io/nuget/v/Shiny.Core.svg?maxAge=2592000" alt="NuGet" /&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Background Jobs - Shiny Style</title>
			<link>https://aritchie.github.io/posts/shinyjobs</link>
			<description>&lt;p&gt;Performing background jobs on mobile is a necessity these days whether you are synchronizing data with your background, triggering notifications to say happy birthday, or just tracking your user for every step they make.  With Shiny, I set out to make this process a breeze.  Android has such a beautiful scheduled jobs engine that keeps improving.  iOS is painful mainly because Apple hates your code that isn't UI.  UWP does have a background tasks which work quite well, but lack some structure.  I attempted to bring most of the "pretty" from Android to Xamarin cross platform!&lt;/p&gt;</description>
			<enclosure url="https://aritchie.github.io/images/shiny_logo.png" length="0" type="image" />
			<guid>https://aritchie.github.io/posts/shinyjobs</guid>
			<pubDate>Fri, 03 May 2019 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="this-artcile-has-been-updated-to-shiny-2.0"&gt;THIS ARTCILE HAS BEEN UPDATED TO SHINY 2.0&lt;/h1&gt;
&lt;img src="images/shiny_logo.png" width="100"&gt; 
&lt;p&gt;Performing background jobs on mobile is a necessity these days whether you are synchronizing data with your background, triggering notifications to say happy birthday, or just tracking your user for every step they make.  With Shiny, I set out to make this process a breeze.  Android has such a beautiful scheduled jobs engine that keeps improving.  iOS is painful mainly because Apple hates your code that isn't UI.  UWP does have a background tasks which work quite well, but lack some structure.  I attempted to bring most of the "pretty" from Android to Xamarin cross platform!&lt;/p&gt;
&lt;p&gt;Jobs is something that is built into the main Shiny library as alot of what it does is the center point of the library and a lot of things will be built on it in the near future :)&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="getting-setup"&gt;Getting Setup&lt;/h2&gt;
&lt;p&gt;Obviously, first things first - install the &lt;a href="https://www.nuget.org/packages/Shiny.Core/"&gt;&lt;img src="https://img.shields.io/nuget/v/Shiny.svg?maxAge=2592000" alt="NuGet"&gt;&lt;/a&gt; package into your head projects as well as your shared project.&lt;/p&gt;
&lt;p&gt;And for your Info.plist&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;key&amp;gt;UIBackgroundModes&amp;lt;/key&amp;gt;
&amp;lt;array&amp;gt;
	&amp;lt;string&amp;gt;fetch&amp;lt;/string&amp;gt;
&amp;lt;/array&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id="adhoc-jobs"&gt;Adhoc Jobs&lt;/h2&gt;
&lt;p&gt;Adhoc jobs are on-the-spot types of execution.  You need something to finish before your app takes a dirt nap... this is the guy to call&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// IJobManager can and should be injected into your viewmodel code
await Shiny.ShinyHost.Resolve&amp;lt;Shiny.Jobs.IJobManager&amp;gt;().RunTask(async () =&amp;gt; 
{
    // your code goes here - async stuff is welcome (and necessary)
});
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id="scheduled-jobs"&gt;Scheduled Jobs&lt;/h2&gt;
&lt;p&gt;Scheduled jobs are the real meat though.  These are really what you need to make things happen when your app is backgrounded or needs to do something with some degree of regularity.  Don't go crazy, you still only get a finite amount of time to work with.  On iOS, this is 30 seconds and not a drop more.&lt;/p&gt;
&lt;p&gt;Note that jobs support injecting your dependencies if they are registered within the Shiny Startup&lt;/p&gt;
&lt;p&gt;So first things first, let's build a job.  Building a job is as simple as implementing Shiny.Jobs.IJob.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class YourFirstJob : Shiny.Jobs.IJob
{
    readonly IYourDepdendency depdency;
    public YourFirstJob(IYourDependency dependency)
    {
        this.dependency = dependency;
    }


    public async Task&amp;lt;bool&amp;gt; Run(JobInfo jobInfo, CancellationToken cancelToken)
    {
        var id = jobInfo.GetValue("Id", 25); // we'll cover this in a minute
        await this.dependency.SomeAsyncMethod(id);

        return true; // this is for iOS - try not to lie about this - return true when you actually do receive new data from the remote method
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lastly, you have to register your job.  With scheduled jobs, I wanted to make sure that I could pass in metadata like last date run, some sort of identifiers, etc.  You also have the ability to set to preconditions of when your job is allowed to run.  Maybe you don't want to run unless you are on WiFi because you want to sync like 500+ megs?  Maybe you are going to run an infinite loop that melts the battery, so you want the battery to be charging or at least be above 20% - well, this is the place to make that happen.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var job = new JobInfo
{
    Name = "YourFirstJob",
    Type = typeof(YourFirstJob),

    // these are criteria that must be met in order for your job to run
    BatteryNotLow = true,
    DeviceCharging = false
    RequiredInternetAccess = InternetAccess.Any,
    Repeat = true //defaults to true, set to false to run once OR set it inside a job to cancel further execution
};

// you can pass variables to your job
job.SetValue("Id", 10);


// lastly, schedule it to go - don't worry about scheduling something more than once, we just update if your job name matches an existing one
await ShinyHost.Resolve&amp;lt;Shiny.Jobs.IJobManager&amp;gt;().Schedule(job);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is good for registering jobs in a controlled fashion in your viewmodel.&lt;/p&gt;
&lt;p&gt;However, if you have a service that you always want to run with your app, you can use a quick trick as part of your shiny startup file.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
namespace YourNamespace
{
    public class Startup : Shiny.ShinyStartup
    {
        var job = new JobInfo
        {
            Name = "YourFirstJob",
            Type = typeof(YourFirstJob),

            // these are criteria that must be met in order for your job to run
            BatteryNotLow = true,
            DeviceCharging = false
            RequiredInternetAccess = InternetAccess.Any,
            Repeat = true //defaults to true, set to false to run once OR set it inside a job to cancel further execution
        };

        services.RegisterJob(job);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id="canceling-jobs"&gt;Canceling Jobs&lt;/h2&gt;
&lt;p&gt;When your user logs out, you likely don't need to keep sucking away at their battery, so cancelling jobs is a necessary action to perform.  You have to ways to cancel jobs, by the specific ID of what you registered as the job name OR cancelling ALL jobs.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Cancelling A Job
Shiny.ShinyHost.Resolve&amp;lt;Shiny.Jobs.IJobManager&amp;gt;().Cancel("YourJobName");

// Cancelling All Jobs
Shiny.ShinyHost.Resolve&amp;lt;Shiny.Jobs.IJobManager&amp;gt;().CancelAll();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id="running-on-demand"&gt;Running On-Demand&lt;/h2&gt;
&lt;p&gt;Unlike adhoc jobs, this is designed to run your registered job(s) when you need them.  On iOS, maybe you are using silent push notifications to give your app a kick to start pulling a gig of data?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Run All Jobs On-Demand
var results = await Shiny.ShinyHost.Resolve&amp;lt;Shiny.Jobs.IJobManager&amp;gt;().RunAll();

// Run A Specific Job On-Demand
var result = await Shiny.ShinyHost.Resolve&amp;lt;Shiny.Jobs.IJobManager&amp;gt;().Run("YourJobName");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NOTE: you can see the result(s) of a job pass by taking a look at the result object!&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="ios-be-prepared"&gt;IOS - Be Prepared&lt;/h2&gt;
&lt;p&gt;iOS is not "periodic" in the sense that you can rely on it to run every X mins.  In fact, it is quite intelligent about when/how it runs.  Do remember, you are piggybacking on "background fetch", so you really need to do some sort of remote data call if you don't want to aggrevate the apple gods that be.&lt;/p&gt;
&lt;h2 id="links"&gt;Links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://aritchie.github.io/introducingshiny"&gt;Initial Shiny Setup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/shinyorg/shiny"&gt;Source Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/shinyorg/shinysamples"&gt;Samples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://shinylib.net"&gt;Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/Shiny.Core/"&gt;&lt;img src="https://img.shields.io/nuget/v/Shiny.Core.svg?maxAge=2592000" alt="NuGet"&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Introducing Shiny</title>
			<link>https://aritchie.github.io/posts/introducingshiny</link>
			<description>&lt;p&gt;Ever wanted to write a backgrounding experience that is consistent across all of the .NET platforms you work with?  Between Xamarin Android, Xamarin iOS, and the Universal Windows Platform (UWP) - there are a variety of issues that I've seen commonly occuring that makes this difficult.  As .NET developers, we often want our dependency injection, our async/awaits, and our general way of doing things in our ecosystem.  The mobile platforms really flipped us on our head.  Android has services &amp;amp; broadcast receivers, iOS has too many different ways of coming at backgrounding, and UWP is somewhere in between.&lt;/p&gt;</description>
			<enclosure url="https://aritchie.github.io/images/shiny_logo.png" length="0" type="image" />
			<guid>https://aritchie.github.io/posts/introducingshiny</guid>
			<pubDate>Wed, 01 May 2019 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="this-article-was-for-shiny-1.x-and-now-deprecated"&gt;THIS ARTICLE WAS FOR SHINY 1.x AND NOW DEPRECATED&lt;/h1&gt;
&lt;h3 id="what-is-it"&gt;What is it?&lt;/h3&gt;
&lt;p&gt;Ever wanted to write a backgrounding experience that is consistent across all of the .NET platforms you work with?  Between Xamarin Android, Xamarin iOS, and the Universal Windows Platform (UWP) - there are a variety of issues that I've seen commonly occuring that makes this difficult.  As .NET developers, we often want our dependency injection, our async/awaits, and our general way of doing things in our ecosystem.  The mobile platforms really flipped us on our head.  Android has services &amp;amp; broadcast receivers, iOS has too many different ways of coming at backgrounding, and UWP is somewhere in between.&lt;/p&gt;
&lt;p&gt;There have been several plugins over time to help combat this problem, but all fail at some point because they lack the necessary infrastructure to bring it all together.  I have seen developers frequently fight this issue with things like BluetoothLE, GPS, Geofencing, background synchronization, etc.  Making this code testable is even harder and often painful to work with.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://aritchie.github.io/images/shiny_logo.png" width="100"&gt; Enter &lt;a href="https://github.com/shinyorg/shiny"&gt;Shiny&lt;/a&gt; - a new framework that tackles problems that no other framework currently tackles - backgrounding and device hardware with all the bells and whistles you are use to in the .NET ecosystem.  Shiny was built on the premise of making depenendency injection and cross platform backgrounding a consistent &amp;amp; testable experience.&lt;/p&gt;
&lt;p&gt;Out of the box, Shiny will offer:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A Centralized Hosting Platform&lt;/li&gt;
&lt;li&gt;Environment (App &amp;amp; Device Information)&lt;/li&gt;
&lt;li&gt;Logging&lt;/li&gt;
&lt;li&gt;Connectivity&lt;/li&gt;
&lt;li&gt;File System &amp;amp; IO Extensions&lt;/li&gt;
&lt;li&gt;Power Management&lt;/li&gt;
&lt;li&gt;Permissions&lt;/li&gt;
&lt;li&gt;Settings&lt;/li&gt;
&lt;li&gt;Background Jobs&lt;/li&gt;
&lt;li&gt;Geofencing&lt;/li&gt;
&lt;li&gt;GPS (Foreground &amp;amp; Background)&lt;/li&gt;
&lt;li&gt;Bluetooth LE (GATT Peripheral &amp;amp; Central)&lt;/li&gt;
&lt;li&gt;Beacons&lt;/li&gt;
&lt;li&gt;Speech Recognition&lt;/li&gt;
&lt;li&gt;HTTP File Transfers&lt;/li&gt;
&lt;li&gt;Sensors&lt;/li&gt;
&lt;li&gt;Notifications&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="why-another-essentials-or-set-of-plugins"&gt;Why Another Essentials or Set of Plugins?&lt;/h3&gt;
&lt;p&gt;Well - to be fair, I've had most of these libraries before some of the other plugins existed.  I also set out to offer a DI and background experience in a cross platform way first.  I also wanted to open the door to other platforms like Tizen, macOS, Linux, Blazor, Uno, &amp;amp; possibly even Meadow as other platforms for the future.  This library has zero focus on UI and will only focus on service processes - I'll leave the frontend stuff to Xamarin Forms &amp;amp; Uno.&lt;/p&gt;
&lt;p&gt;Current plugins also tend to lack features because they need an underlying layer to help keep things in check.  For instance, Plugin.Jobs (one of my plugins) spins up periodic jobs.  These jobs are essentially useless if you can't get your service layer into them in a consistent manner.&lt;/p&gt;
&lt;h2 id="interoperability"&gt;Interoperability&lt;/h2&gt;
&lt;p&gt;Because Shiny sits a bit higher in the execution pipeline (before Xamarin Forms gets going for example), it has its own set of registration principles and bootstrapping.  However, I wanted to play nice with Xamarin Forms &amp;amp; great frameworks like MvvmCross and Prism (shoot to Dan &amp;amp; Brian - you guys are awesome)!  There are already mechanisms to help these frameworks play nice out of the box from Day 1, but there is a roadmap to make this experience nearly seemless in the near future.&lt;/p&gt;
&lt;h3 id="at-its-core"&gt;At It's Core&lt;/h3&gt;
&lt;p&gt;Shiny was built with Reactive Extensions (RX) and Microsoft Extension (DI) out of the box.  The Microsoft.Extensions.DependencyInjection had the greatest balance of speed, flexibility, and forward thinking support.  Reactive Extensions brings a different paradigm of programming which is often seen as complex.  I choose to embrace it because all other ecosystems embrace it fully (RXJS, Flutter, Java, etc).  I argue that RX isn't complex, it is powerful.  Shiny wants to offer that power at its roots!  As for dependency injection, it often has the same set of arguments and that it is slow.  For backgrounding, DI is extremely POWERFUL and gives you your infrastructure &amp;amp; business logic where you need it.  It also makes your code testable!&lt;/p&gt;
&lt;h3 id="lets-see-it-in-action"&gt;Let's see it in action&lt;/h3&gt;
&lt;p&gt;Step 1 - Install from nuget (given)
Step 2 - In your xplat project, create
Step 3 - Create your "Startup" class&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// this sample uses everything imaginable in Core - YOU DO NOT NEED IT ALL
using Shiny;
using Shiny.BluetoothLE;
using Shiny.Beacons;
using Shiny.Logging;
using Shiny.Locations;
using Shiny.Notifications;
using Shiny.Sensors;
using Shiny.SpeechRecognition;
using Shiny.Net.Http;
using Microsoft.Extensions.DependencyInjection;


namespace Samples
{
    public class SampleStart : ShinyStartup
    {
        public override void ConfigureServices(IServiceCollection builder)
        {
            // custom logging
            Log.UseConsole();
            Log.UseDebug();

            // create your infrastructure
            builder.AddSingleton&amp;lt;SampleSqliteConnection&amp;gt;();

            // register all of the acr stuff you want to use
            builder.UseHttpTransfers&amp;lt;SampleDelegate&amp;gt;();
            builder.UseBeacons&amp;lt;SampleDelegate&amp;gt;();
            builder.UseBleCentral();
            builder.UseBlePeripherals();
            builder.UseGpsBackground&amp;lt;SampleDelegate&amp;gt;();
            builder.UseGeofencing&amp;lt;SampleDelegate&amp;gt;();
            builder.UseNotifications();
            builder.UseSpeechRecognition();

            builder.UseAccelerometer();
            builder.UseAmbientLightSensor();
            builder.UseBarometer();
            builder.UseCompass();
            builder.UseDeviceOrientationSensor();
            builder.UseMagnetometer();
            builder.UsePedometer();
            builder.UseProximitySensor();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="step-4-create-some-delegates"&gt;Step 4 - Create Some Delegates&lt;/h3&gt;
&lt;p&gt;Notice those "SampleDelegate" generics above, that's where you register your background handler(s).  It is truly this simple to get up and running.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// again - this runs everything and the kitchen sink - pick and choose what you need
using System;
using System.Threading;
using System.Threading.Tasks;
using Shiny;
using Shiny.Beacons;
using Shiny.BluetoothLE.Central;
using Shiny.Locations;
using Shiny.Jobs;
using Shiny.Net.Http;
using Shiny.Notifications;
using Samples.Models;


namespace Samples
{
    public class SampleAllDelegate : IGeofenceDelegate,
                                     IGpsDelegate,
                                     IBeaconDelegate,
                                     IHttpTransferDelegate,
                                     IBleStateRestoreDelegate,
                                     IJob
    {
        // notice you can inject anything you registered in your application here
        readonly SampleSqliteConnection conn;
        readonly INotificationManager notifications;


        public SampleAllDelegate(SampleSqliteConnection conn, INotificationManager notifications)
        {
            this.conn = conn;
            this.notifications = notifications;
        }



        public async Task OnConnected(IPeripheral peripheral)
        {
        }


        public async Task OnStatusChanged(GeofenceState newStatus, GeofenceRegion region)
        {
        }


        public async Task OnStatusChanged(BeaconRegionState newStatus, BeaconRegion region)
        {
        }


        public async Task&amp;lt;bool&amp;gt; Run(JobInfo jobInfo, CancellationToken cancelToken)
        {
            return true;
        }


        public async Task OnError(HttpTransfer transfer, Exception ex)
        {
        }


        public async Task OnCompleted(HttpTransfer transfer)
        {
        }


        public async Task OnReading(IGpsReading reading)
        {
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="step-5.1-initializing-ios"&gt;Step 5.1 - Initializing iOS&lt;/h3&gt;
&lt;p&gt;iOS is pretty easy - GO to AppDelegate and add the following stuff&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// in your FinishedLaunching method
Shiny.iOSShinyHost.Init(new Startup(), services =&amp;gt; 
{
    // register any platform specific stuff you need here
});

// and add this guy - if you don't use jobs, you won't need it
public override void PerformFetch(UIApplication application, Action&amp;lt;UIBackgroundFetchResult&amp;gt; completionHandler)
    =&amp;gt; JobManager.OnBackgroundFetch(completionHandler);

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="step-5.2-initializing-android"&gt;Step 5.2 - Initializing Android&lt;/h4&gt;
&lt;p&gt;Android requires a fair bit more setup to get going.  Android requires a top level custom Application definition.  This is necessary as the Host needs to be initialized prior to any services or broadcast receivers warming up.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System;
using Android.App;
using Android.Runtime;


[Application]
public class YourApplication : Application
{
    public YourApplication(IntPtr handle, JniHandleOwnership transfer) : base(handle, transfer)
    {
    }


    public override void OnCreate()
    {
        base.OnCreate();
        Shiny.AndroidShinyHost.Init(this, new Startup(), services =&amp;gt; {
            // register any platform specific stuff you need here
        });
    }
}


// and lastly - in your main/current activity

public override void OnRequestPermissionsResult(int requestCode, string[] permissions, Permission[] grantResults)
{
    Shiny.AndroidShinyHost.OnRequestPermissionsResult(requestCode, permissions, grantResults);
    base.OnRequestPermissionsResult(requestCode, permissions, grantResults);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="like-what-you-see"&gt;Like What You See?&lt;/h3&gt;
&lt;p&gt;Head over to see the full &lt;a href="https://github.com/shinyorg/shinysamples"&gt;GitHub Samples&lt;/a&gt; or official documentation located &lt;a href="https://shinydocs.azurewebsites.net"&gt;here&lt;/a&gt;.  Packages on nuget can be found &lt;a href="https://www.nuget.org/packages?q=shiny"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Follow the &lt;a href="https://aritchie.github.io/tags/shiny"&gt;links here&lt;/a&gt; for more upcoming articles&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>