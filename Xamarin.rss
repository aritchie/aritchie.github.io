<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title>Allan Ritchie's Blog</title>
		<link>https://aritchie.github.io/</link>
		<description />
		<copyright>2022</copyright>
		<pubDate>Mon, 11 Jul 2022 13:21:57 GMT</pubDate>
		<lastBuildDate>Mon, 11 Jul 2022 13:21:57 GMT</lastBuildDate>
		<item>
			<title>Shiny 2.0 For Xamarin - Shinier Than Ever</title>
			<link>https://aritchie.github.io/posts/shiny20</link>
			<description>&lt;p&gt;Shiny is a Xamarin Framework designed to make dealing with device &amp;amp; background services easy by bringing things like dependency injection, logging, and lots of utilities to bring your workflows to the background
in friendly, testable, way!&lt;/p&gt;</description>
			<enclosure url="https://aritchie.github.io/images/shiny_logo.png" length="0" type="image" />
			<guid>https://aritchie.github.io/posts/shiny20</guid>
			<pubDate>Wed, 05 May 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="the-path-to-2.0"&gt;The Path to 2.0&lt;/h2&gt;
&lt;p&gt;Shiny is a Xamarin Framework designed to make dealing with device &amp;amp; background services easy by bringing things like dependency injection, logging, and lots of utilities to bring your workflows to the background
in friendly, testable, way!&lt;/p&gt;
&lt;p&gt;Version 2.0 is months of work, hundreds of commits (1166 to be exact), and a lot of discovery around how to improve the end experience.  This release focused on improving the background experience
even more especially on Android.  Android is the source of great pain when it comes to backgrounding and especially around expectations that people
have (for instance, real time background GPS).  As such, Shiny now uses foreground services in most of these places.  As a developer using Shiny, this is completely
transparent change for you unless you want to customize the notification.&lt;/p&gt;
&lt;p&gt;Now that I'm done with the boring rant.  Let's talk about some of the cool new features&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://aritchie.github.io/#death-to-boilerplate-code"&gt;Boilerplate Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://aritchie.github.io/#static-class-generation"&gt;Static Class Generation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://aritchie.github.io/#logging"&gt;Microsoft Extensions Logging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://aritchie.github.io/#bluetooth-le"&gt;BluetoothLE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://aritchie.github.io/#notifications"&gt;Local Notifications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://aritchie.github.io/#push-notifications"&gt;Push Notifications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://aritchie.github.io/#beacons"&gt;Beacons&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="death-to-boilerplate-code"&gt;Death to Boilerplate Code&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;This was the first source of support pain and issues that users had was usually missed (or wrong) setup.  In 2.0, I set out for how to remove this issue.  With the latest C# 9/.NET5 release,
source generators were released.  This allows for code to be injected in the places Shiny needed it.  To make things even more convenient for users, I can also wire up all of their
Xamarin Forms, Xamarin Essentials, and other 3rd party source code.&lt;/p&gt;
&lt;p&gt;To get an idea, here is a before and after showing both iOS and Android boilerplate&lt;/p&gt;
&lt;!--?# TabGroup ?--&gt;
&lt;!--?*
tabs:
  - name: Android Before
    include: "../../includes/shiny20/androidbefore.md"

  - name: Android After
    include: "../../includes/shiny20/androidafter.md"

  - name: iOS Before
    include: "../../includes/shiny20/iosbefore.md"

  - name: iOS After
    include: "../../includes/shiny20/iosafter.md"
?--&gt;
&lt;!--?#/ TabGroup ?--&gt;
&lt;p&gt;To get this "voodoo" magic.  Simply install the &lt;!--?# NugetShield "Shiny" "Shiny" /?--&gt; nuget package into your head projects and add the attribute as shown in the "after" tabs above.  Also note how the activity and appdelegate are partial.
These new generators can even build your entire startup class, but that's a discussion for a future article :)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTE: If you are using this on Azure DevOps or CI systems, MSBuild 16.8 is required which is not part of Mono yet.  You need to use a tool like Boots to update to the latest beta OR simply use the "BEFORE" versions above and install &lt;!--?# NugetShield "Shiny.Core" "Shiny.Core" /?--&gt; instead&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="static-class-generation"&gt;Static Class Generation&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;There are a lot of users that don't like dependency injection.  I can't see or live in a world without it (for now).&lt;br&gt;
With those thoughts in mind, source generators once again came to the rescue.  All you need to do is install the &lt;a href="https://www.nuget.org/packages/Shiny/" target="Shiny"&gt;&lt;img src="https://img.shields.io/nuget/v/Shiny.svg?style=for-the-badge&amp;amp;label=Shiny"&gt;&lt;/a&gt; in the library where you want the classes generated and add the attribute in any file as shown below.
For any Shiny library you have installed in your library, the source generator will create a static equivalent class of the interface.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[assembly: StaticClasses("ILikeStatics")]

// core jobs
ILikeStatics.ShinyJobs.Register(...);

// ble
ILikeStatics.ShinyBle.Scan();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pretty statics and NO dependency injection to be seen anywhere.  You still have to create a startup file though ;)&lt;/p&gt;
&lt;h2 id="logging"&gt;Logging&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;Logging is generally something you want in your app.  When you work in the background, you can't rely on the general dev experience of errors appearing in your VS output window.&lt;br&gt;
While libraries like AppCenter and Firebase help with crashes, it can be quite dangerous to build them directly into all of your views/viewmodels/classes/etc. Logging providers also tend to disappear and change over time.&lt;/p&gt;
&lt;p&gt;With that being said, I also didn't want to write new providers to plugin into Shiny.  There was an easy answer to this problem - Use Microsoft.Extensions.Logging - the exact same library used by ASP.NET Core devs!  It is a fantastical abstraction
to build on and support DI out of the gate!  The only thing that was missing was logging providers for AppCenter &amp;amp; Firebase - so I've added the following libs to Shiny&lt;/p&gt;
&lt;!--?# NugetShield "Shiny.Logging.Firebase" "Shiny.Logging.Firebase" /?--&gt;
&lt;!--?# NugetShield "Shiny.Logging.AppCenter" "Shiny.Logging.AppCenter" /?--&gt;
&lt;p&gt;Wiring providers up is also almost just like ASP.NET Core.  In your Shiny startup file:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System;
using Shiny;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;


namespace YourApp
{
    public class YourStartup : ShinyStartup
    {
        public override void ConfigureLogging(ILoggingBuilder builder, IPlatform platform)
        {
			builder.AddFirebase();
			builder.AddAppCenter("your appcenter key");
        }
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="notifications"&gt;Notifications&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;Notifications in Shiny still provide all of the features imaginable for your Xamarin cross platform needs.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Scheduling&lt;/li&gt;
&lt;li&gt;Actions&lt;/li&gt;
&lt;li&gt;Sounds&lt;/li&gt;
&lt;li&gt;Priorities&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With 2.0, Notifications had to undergo some changes to make sure things like sounds worked and response actions from notifications were consistent across platforms, thus, channels were
created as to play ball properly with channels on Android and to a far lesser degree, categories on iOS.&lt;/p&gt;
&lt;p&gt;Channels are essentially configuration groups.  This provides equivalent functionality to what you find on Android 8+ such as&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Priority&lt;/li&gt;
&lt;li&gt;Sounds&lt;/li&gt;
&lt;li&gt;Actions - Text Replies, Buttons, etc&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With iOS, "channels" equate in a way to categories, but apply more to the available actions on a given notification.  With that in mind, I had to bring these two
worlds together for a consistent design between them (oh... and that UWP thing can come along too).  What's better, channel is required on Android - if you don't care
about the additional functionality - omit it and Shiny will default it for you!&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;var manager = ShinyHost.Resolve&amp;lt;Shiny.Notifications.INotificationManager&amp;gt;(); // INJECT THIS
await manager.AddChannel(new Channel 
{
	Identifier = "YourChannelName",
	Description = "This is your channel",
	Importance = ChannelImportance.Normal // normal+ will add default sounds on android
	CustomSoundPath = "notification.mp3",
	Actions =
	{
		new ChannelAction
		{
			Identifier = "message",
			Title = "Leave a Message",
			ActionType = ChannelActionType.TextReply
		},
		new ChannelAction
		{
			Identifier = "freeticket",
			Title = "Free Ticket",
			ActionType = ChannelActionType.Destructive
		}
	}
});

// BONUS - got a resource file that you want to use instead - make sure to call this before AddChannel
channel.SetSoundFromEmbeddedResource(this.GetType().Assembly, "Samples.Resources.notification.mp3");


// now to use it
await manager.Send(
	"WELCOME TO THE CN Tower",
	"What would you like to do?",
	"YourChannelName"
)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which gives you this!&lt;/p&gt;
&lt;p&gt;&lt;img src="https://aritchie.github.io/images/shiny20/notificationactions.gif" alt="Actions1"&gt;&lt;/p&gt;
&lt;h2 id="push-notifications"&gt;Push Notifications&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;Over the last few years, push notification providers have come and gone.  Google has gone from GCM to Firebase - Other 3rd party push providers have dropped like flies for one reasons or another (ie. AppCenter).
If you don't have a good design pattern in place, you aren't left a rough spot of being forced to refactor things.&lt;/p&gt;
&lt;p&gt;As of the 2.0 release, Shiny supports:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Native&lt;/li&gt;
&lt;li&gt;Firebase&lt;/li&gt;
&lt;li&gt;Azure Notification Hubs&lt;/li&gt;
&lt;li&gt;With OneSignal &amp;amp; AWS coming in the near future&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Why is this such an awesome API? Because you can swap between push notification providers with 1 single line of code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Microsoft.Extensions.DependencyInjection;
using Shiny;

namespace YourNamespace
{
    public class YourShinyStartup : ShinyStartup
    {
        public override void ConfigureServices(IServiceCollection services, IPlatform platform)
        {
            
				// NATIVE
				services.UsePush&amp;lt;MyPushDelegate&amp;gt;(); // native
       
				// OR FIREBASE 
				services.UseFirebaseMessaging&amp;lt;MyPushDelegate&amp;gt;();

				// OR AZURE NOTIFICATION HUBS
				services.UsePushAzureNotificationHubs&amp;lt;MyPushDelegate&amp;gt;(
					"Your Listener Connection String",
					"Your Hub Name"
				);

        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This doesn't cover the general push setup like the Info/Entitlements.plist setup and google-services.json.  This will be covered in the docs.&lt;/p&gt;
&lt;p&gt;Now that we've wired it up, let's request the user permission and get a token.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var result = await ShinyHost.Resolve&amp;lt;Shiny.Push.IPushManager&amp;gt;.RequestAccess();
if (result.Status == Shiny.AccessState.Available) 
{
    result.RegistrationToken; // maybe you want to send this to your server to use in notifications
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And lastly, how you actually get "pushes".  This method is particularily useful if you are doing a real time app for something like chat.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Foreground&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var subscription = ShinyHost
	.Resolve&amp;lt;Shiny.Push.IPushManager&amp;gt;()
	.WhenReceived(push =&amp;gt; {
		var value = push.Data["ThisIsADictionary"];
		var title = push.Notification?.Title; // warning: notifications can be null
	});

// make sure to dispose when you're done or going to the background
subscription.Dispose();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Background (this still runs in the foreground)&lt;/strong&gt;&lt;/em&gt;
The background, as with all things in Shiny, is where things begin to shine. The OnReceived is where most of the magic will happen for you.  From here, you can process a push notification
and do things like call out to an HTTP service to refresh data, maybe acknowledge that your user is available for shift work if they have "punched" into your app.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Shiny.Push;
using System.Threading.Tasks;

namespace Shiny20Sample
{
    public class MyPushDelegate : IPushDelegate
    {
        public async Task OnEntry(PushNotificationResponse response)
        {
        }

        public async Task OnReceived(PushNotification notification)
        {
        }

        public async Task OnTokenChanged(string token)
        {
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="tag-support"&gt;Tag Support&lt;/h3&gt;
&lt;p&gt;Tags are a way of telling the push provider (if supported), I want to listen to these "topics".  This is supported by all of the 3rd party
messaging systems like Firebase &amp;amp; Azure Notifications Hubs.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// will not be null if supported
var tagPushManager = ShinyHost.Resolve&amp;lt;IPushManager&amp;gt;() as IPushTagSupport;
await tagPushManager.AddTag("YourTag");
await tagPushManager.RemoveTag("YourTag");
await tagPushManager.ClearTags();
await tagPushManager.SetTags("tag1", "tag2"); // remove tags that aren't present and add new tags
tagPushManager.RegisteredTags; // your current set of registered tags

// OR use the friendly extension methods off the push manager
var push = ShinyHost.Resolve&amp;lt;IPushManager&amp;gt;();
await push.TryAddTag(...);
await push.TryRemoveTag(...);
await push.TryClearTags(...);

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="bluetooth-le"&gt;Bluetooth LE&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;I really went through all of the API calls this library had to offer.&lt;/p&gt;
&lt;p&gt;BLE is still firmly (and always will be) rooted in Reactive Extensions, but I wanted to make the APIs easier to consume for all users including myself.&lt;/p&gt;
&lt;p&gt;Today, I'm only going to talk about 2 of the super cool features that are new with 2.0.  The Managed BLE mechanics:&lt;/p&gt;
&lt;h4 id="managed-scans"&gt;Managed Scans&lt;/h4&gt;
&lt;p&gt;Scanning was riddled with potential issues&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;maintaining a list of unique peripherals while still watching things like the RSSI and name changes&lt;/li&gt;
&lt;li&gt;synchronizing list updates to your UI&lt;/li&gt;
&lt;li&gt;Removing a device from the list that hasn't been heard in a specific time&lt;/li&gt;
&lt;li&gt;preventing the scan from overwhelming your UI with redraws (and subsequently making sure you're on the UI thread when doing anything)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It took a fair of code to manage this even with Shiny, but with the new managed scanner - take a look at the difference:&lt;/p&gt;
&lt;!--?# TabGroup ?--&gt;
&lt;!--?*
tabs:
  - name: Before
    include: "../../includes/shiny20/blescanbefore.md"

  - name: After
    include: "../../includes/shiny20/blescanafter.md"
?--&gt;
&lt;!--?#/ TabGroup ?--&gt;
&lt;h4 id="managed-peripheral"&gt;Managed Peripheral&lt;/h4&gt;
&lt;p&gt;The problem with traditional peripheral managed is that with every connection, you had to rescan for all of the services and characteristics you had.  You also had to restore any notifications you had.
This was painful.&lt;/p&gt;
&lt;p&gt;Managed peripheral to the rescue. The managed peripheral will&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Work like a ViewModel - you can even have it broadcast it's changes on the UI thread for you to bind to&lt;/li&gt;
&lt;li&gt;Reconnect automatically&lt;/li&gt;
&lt;li&gt;Restore any characteristic subscription&lt;/li&gt;
&lt;li&gt;Read/Writes will redetect the characteristics as you used them.  This saves using GetCharacteristic to continously and thereby increasing performance&lt;/li&gt;
&lt;li&gt;Keeps a list of characteristics you've used instead of having to call GetServices/GetCharacteristics over and over&lt;/li&gt;
&lt;/ul&gt;
&lt;!--?# TabGroup ?--&gt;
&lt;!--?*
tabs:
  - name: Before
    include: "../../includes/shiny20/bleperipheralbefore.md"

  - name: After
    include: "../../includes/shiny20/bleperipheralafter.md"
?--&gt;
&lt;!--?#/ TabGroup ?--&gt;
&lt;h2 id="beacons"&gt;Beacons&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;Beacons aren't really new, but there has always been a bit of a gap here in the Xamarin community.  You also had to always count on the beacon manufacturer supplying an SDK.
With Shiny, you get iBeacon (yes the Apple Beacons) out of the box on all of the platforms Shiny supports.  The thing I love about this library is that it is 100% C# and supports all of the monitoring/background scenarios
on Android as well!&lt;/p&gt;
&lt;p&gt;Here's a quick look at the main beacon features&lt;/p&gt;
&lt;h3 id="the-wireup"&gt;The Wireup&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Microsoft.Extensions.DependencyInjection;
using Shiny;

namespace YourNamespace
{
    public class YourShinyStartup : ShinyStartup
    {
        public override void ConfigureServices(IServiceCollection services, IPlatform platform)
        {
            
				// NOTE: there are 2 different services for beacons 
				// for ranging - finding individual beacons in the foreground
				services.UseBeaconRanging();
       
				// for monitoring - finding beacon groups (not individual beacons) in the background
				services.UseBeaconMonitoring&amp;lt;MyBeaconMonitorDelegate&amp;gt;();

        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="background-beacons"&gt;Background Beacons&lt;/h4&gt;
&lt;p&gt;Setting up background monitoring is pretty simple.  Once you've registered, simply call:&lt;/p&gt;
&lt;p&gt;Here's your delegate:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Shiny.Beacons;
using System.Threading.Tasks;

namespace Shiny20Sample
{
    public class MyBeaconMonitorDelegate : IBeaconMonitorDelegate
    {
        public async Task OnStatusChanged(BeaconRegionState newStatus, BeaconRegion region)
        {
            // send notifications to say hello or goodbyte
            // call an http service to track your users
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and the code to start monitoring:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;await ShinyHost
	.Resolve&amp;lt;Shiny.Beacons.IBeaconMonitorManager&amp;gt;()
	.StartMonitoring(new BeaconRegion(...)) // from here, simply setup the filter criteria you need - remember you only get 20 on iOS!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Simple right!?  StartMonitoring will even request all of the appropropriate permissions!&lt;/p&gt;
&lt;h4 id="managed-ranging-scan"&gt;Managed Ranging Scan&lt;/h4&gt;
&lt;p&gt;This essentially works identical to the new managed BLE scan shown earlier with all of the same benefits&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It will use best practices to ensure your UI isn't overwhelmed with updates&lt;/li&gt;
&lt;li&gt;It will ensure that the bound collection is properly synchronized to prevent crashes&lt;/li&gt;
&lt;li&gt;It will remove beacons from your list that haven't been "heard" in a configurable timestamp&lt;/li&gt;
&lt;li&gt;It will manage the individual items with proximity changes&lt;/li&gt;
&lt;/ul&gt;
&lt;!--?# TabGroup ?--&gt;
&lt;!--?*
tabs:
  - name: Before
    include: "../../includes/shiny20/beaconscanbefore.md"

  - name: After
    include: "../../includes/shiny20/beaconscanafter.md"
?--&gt;
&lt;!--?#/ TabGroup ?--&gt;
&lt;h2 id="in-closing"&gt;In Closing&lt;/h2&gt;
&lt;p&gt;This article only scrapped the surface of the 2.0 upgrade.  There's more articles to come and the docs are shaping up nicely.  There are also other packages like NFC, Speech to Text, BLE Hosting, Sensors, and HTTP Transfers that all still exists.  They just didn't see any
huge feature updates in this release.&lt;/p&gt;
&lt;p&gt;I want to thank my good friend &lt;a href="https://twitter.com/DanJSiegel"&gt;Dan Siegel&lt;/a&gt; of Prism fame for all of the help, testing, tooling, suggesting, blog articles, and poking (cough...nagging).  Shiny and the Xamarin community as a whole is a better place because of him.
His work on &lt;a href="https://mobilebuildtools.com/"&gt;Mobile Build Tools&lt;/a&gt; was also immensely helpful for the Shiny samples and integration tests.&lt;/p&gt;
&lt;p&gt;The future of Shiny now begins to look towards app services which moves from device &amp;amp; background servicing to truly solving real world business cases.  Some of the things I'm working on:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GeoDispatch - Push + GPS for incident management scenarios&lt;/li&gt;
&lt;li&gt;GPS Tags - like the airtags but with normal beacons and GPS&lt;/li&gt;
&lt;li&gt;Trip Tracker - tracks your runs, walks, drives, etc in one easy to use API&lt;/li&gt;
&lt;li&gt;OBD Communications - Talking to these things even with the Shiny BLE API is still a bit of work.  This is going to make it easy!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I'm also still considering future platforms like WASM &amp;amp; macOS, but we'll see how the ecosystem shapes up.  I also want to mention that I've been working with the MAUI team on integrations.  I'll have more to share later this year as it stabilizes.&lt;/p&gt;
&lt;p&gt;As with all OSS, Shiny is always looking for help.  Head over to GitHub if you've got an issue to report, an enhancement idea, or if you just want to help out.&lt;/p&gt;
&lt;h2 id="links"&gt;LINKS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!--?# ConfiguredLink "Documentation" /?--&gt;
&lt;/li&gt;
&lt;li&gt;&lt;!--?# ConfiguredLink "Samples" /?--&gt;
&lt;/li&gt;
&lt;li&gt;&lt;!--?# ConfiguredLink "GitHub" /?--&gt;
&lt;/li&gt;
&lt;li&gt;&lt;!--?# ConfiguredLink "AllNugets" /?--&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Startup Tasks, Modules, and Stateful Delegates - Shiny Style</title>
			<link>https://aritchie.github.io/posts/shiny-di</link>
			<description>&lt;p&gt;Shiny isn't all about backgrounding, DI, RX, and all of that cool stuff.  It actually provides a ton of utility functions as well.&lt;/p&gt;</description>
			<enclosure url="https://aritchie.github.io/images/toronto_pan.jpg" length="0" type="image" />
			<guid>https://aritchie.github.io/posts/shiny-di</guid>
			<pubDate>Mon, 01 Jul 2019 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="this-article-applies-to-all-versions-of-shiny"&gt;THIS ARTICLE APPLIES TO ALL VERSIONS OF SHINY&lt;/h1&gt;
&lt;p&gt;Shiny isn't all about backgrounding, DI, RX, and all of that cool stuff.  It actually provides a ton of utility functions as well.&lt;/p&gt;
&lt;p&gt;I love Autofac and a lot of the functions it has.  It really is a great DI framework though is known for being a tad on the slow side.  With Shiny, I went with Microsoft.Extensions.DependencyInjection as the DI platform of choice.  It is fast, has "enough" features, built on a great set of abstractions, and has monolith company backing it.  However, it is no Autofac in terms of features - so I wanted to carry a few of them forward.  Namely, modules and startables.  I've also added a very useful feature in stateful delegates which is my personal favorite!  I'll explain what this in this article as well.&lt;/p&gt;
&lt;h2 id="modules"&gt;Modules&lt;/h2&gt;
&lt;p&gt;Inversion of Control (IoC) acts as the basic building blocks of your application.  However, as your application grows, registering all of these components within a single point of entry can lead to a fat file.&lt;/p&gt;
&lt;p&gt;Modules help by alleviating this.  They are used to help decouple your libraries, so that you can bundle up a set of related components behind a neatly wrapped package to simplify deployment and management of your application. Modules can also help by entangling bits of configuration code internal to library itself instead of literating your startup file with all of these additional flags.&lt;/p&gt;
&lt;p&gt;Below is an example of the data registration module that I use within one of my sample apps &lt;a href="https://github.com/aritchie/stream-todo"&gt;Shiny TODOs&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System;
using Microsoft.Extensions.DependencyInjection;
using Refit;
using Shiny;
using Shiny.Jobs;


namespace Todo.Data
{
    public class DataModule : ShinyModule
    {
        public override void Register(IServiceCollection services)
        {
            services.AddSingleton(_ =&amp;gt; RestService.For&amp;lt;IApiClient&amp;gt;(Constants.BaseApiUri));
            services.AddSingleton&amp;lt;TodoSqliteConnection&amp;gt;();
            services.AddSingleton&amp;lt;IDataService, SqliteDataService&amp;gt;();

            services.RegisterJob(new JobInfo
            {
                Identifier = nameof(SyncJob),
                Type = typeof(SyncJob),
                BatteryNotLow = true,
                RequiredInternetAccess = InternetAccess.Any
            });
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, you can see I'm injecting a SQLite connection, a data service provider, a remote API, and even registering a background job to synchronize the data to/from the server.  You may ask why this is good?  Well - the SQLite connection, api client, and job are all outside of my domain - meaning, the application as a whole, really doesn't have knowledge of their existence (nor should they).  They are just pieces of work that this particular portion of the app needs to do its job without effecting things around it.&lt;/p&gt;
&lt;p&gt;All that is left is to wire this into your Shiny startup (make sure you reference your library if it is a separate project).&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Shiny;


namespace Todo
{
    public class ShinyStartup : ShinyStartup
    {
        public override void ConfigureServices(IServiceCollection services)
        {
            services.RegisterModule&amp;lt;Todo.Data.DataModule&amp;gt;();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="startup-tasks"&gt;Startup Tasks&lt;/h2&gt;
&lt;p&gt;The IStartable/AutoActivate in Autofac is awesome as long as you used it in a smart way.  This concept does not exist in Microsoft's DI extensions.  These startables are something I use fairly frequently in my applications for various background tasks.&lt;/p&gt;
&lt;p&gt;Startup tasks in Shiny are similar to IStartable's in Autofac if you've ever used them.  Since Shiny is essentially DI agnostic, I wanted this feature to be available to all things DI.&lt;/p&gt;
&lt;h3 id="how-do-startup-tasks-differ-from-a-job"&gt;How do startup tasks differ from a job?&lt;/h3&gt;
&lt;p&gt;This is a great &amp;amp; likely common question I suspect, but also very easy to answer.  Startup tasks happen at the point of the container build when all of your services are ready to go.  The difference is that these tasks don't run in the background.  What they offer is a way of hooking up general pipeline logic within your app.  WARNING: These startup tasks should execute very quickly as you will pay a startup cost.  Also note, startup tasks are NOT async.  There are many, many, many reasons for this.  They are designed to hook up internal events and maybe wire up some necessary infrastructure... nothing more!&lt;/p&gt;
&lt;h3 id="what-would-i-do-with-one-of-these"&gt;What would I do with one of these?&lt;/h3&gt;
&lt;p&gt;I often like to wire up my auth service that has a "SignOut" event.  When that signout event fires, I may delete a local database, clear all notifications, etc.&lt;/p&gt;
&lt;h3 id="how-do-i-make-one"&gt;How do I make one?&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class YourStartupTask : Shiny.IShinyStartupTask
{
    public YourStartupTask()
    {
        // you can inject just like everything else in shiny
    }

    public void Start()
    {
        // do your hooking of events and init stuff here :)
    }
}

// in your shiny startup
public void ConfigureServices(IServiceCollection builder)
{
    builder.RegisterStartupTask&amp;lt;YourStartupTask&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="stateful-delegates"&gt;Stateful Delegates&lt;/h2&gt;
&lt;p&gt;My good friend Dan Siegel had been asking for something to help him manage GPS state and even used a decent trick with something that was already built into Shiny - the strong typed settings library.  Take a look at this &lt;a href="https://aritchie.github.io/shinysettings"&gt;article&lt;/a&gt; to see what's going on there.  I decided to build this into all event delegates that Shiny uses. All you have to do is make your delegate inherit from INotifyPropertyChanged, make your "stateful" properties public get/set, and raise notifications on their state changes.  While the sample below can be accomplished easier otherways, as the stateful properties become larger, this pattern begins to pay off - so I hope you're as excited about this as I am!!&lt;/p&gt;
&lt;p&gt;NOTE: this does not work on jobs.  Jobs have their own special type of state management using the JobInfo argument in Run.  This may change in the future.&lt;/p&gt;
&lt;p&gt;Here's a great example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System;
using System.Threading.Tasks;
using Samples.Models;
using Shiny.Notifications;
using Shiny.Locations;


namespace Samples.ShinyDelegates
{
    public class YourGeofenceDelegate : Shiny.NotifyPropertyChanged, Shiny.Locations.IGeofenceDelegate
    {
        readonly INotificationManager notifications;
        public YourGeofenceDelegate(INotificationManager notifications)
        {
            this.notifications = notifications;
        }


        bool welcomed;
        public bool HasAlreadyBeenWelcomed
        {
            get =&amp;gt; welcomed;
            set =&amp;gt; Set(ref welcomed, value);
        }


        public async Task OnStatusChanged(GeofenceState newStatus, GeofenceRegion region)
        {
            if (!this.HasAlreadyBeenWelcomed)
            {
                await this.notifications.Send("WELCOME", "Houston welcomes you the first ever Xamarin Developer Summit"); // yes, you can see where this was used :)
                this.HasAlreadyBeenWelcomed = true;
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So next time this guy fires, whether from the background, reboot, etc - that state will be remembered.  This is pretty epic in my opinion!&lt;/p&gt;
&lt;p&gt;Note, I had considered serializing &amp;amp; deserializing stateful properties (get/set) per delegate trigger, but with things like GPS that can fire rapidly, this may introduce performance issues.  The advantage to serializing/deserializing per run - is that you don't need a viewmodelish type setup.  Just plain old-C# public get/sets.&lt;/p&gt;
&lt;h2 id="in-closing"&gt;In Closing&lt;/h2&gt;
&lt;p&gt;Modules &amp;amp; startup tasks provide a great way to modulizing your application and providing a rich set of wiring services together without coupling them within your normal application logic (ie. ViewModels).&lt;/p&gt;
&lt;h2 id="links"&gt;Links&lt;/h2&gt;
&lt;!--?# DefaultBlogLinks /?--&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Beacons - Shiny Style</title>
			<link>https://aritchie.github.io/posts/shiny-beacons</link>
			<description>&lt;p&gt;Beacons are low powered IoT devices that emit a signal over Bluetooth advertising that contains a specific (and very small piece of data) that is like an address.  You attach that address to a "location" of some type.  They are like an invisible light house.  If you have a device that can "see" those signals, you can find out how close you are to it.&lt;/p&gt;</description>
			<enclosure url="https://aritchie.github.io/images/shiny_beacons.png" length="0" type="image" />
			<guid>https://aritchie.github.io/posts/shiny-beacons</guid>
			<pubDate>Mon, 10 Jun 2019 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="what-are-beacons"&gt;What are Beacons&lt;/h2&gt;
&lt;p&gt;Beacons are low powered IoT devices that emit a signal over Bluetooth advertising that contains a specific (and very small piece of data) that is like an address.  You attach that address to a "location" of some type.  They are like an invisible light house.  If you have a device that can "see" those signals, you can find out how close you are to it.&lt;/p&gt;
&lt;p&gt;Some beacons include sensors like temperature, accelerometers, ambient light, pressure, and more.  Head over to &lt;a href="https://estimote.com/products/"&gt;Estimote&lt;/a&gt; to take a look.  These guys are essentially the Rolls Royce of the beacon industry.&lt;/p&gt;
&lt;p&gt;Beacons from a software perspective actually come in several flavours/protocols.  The main one in practice is iBeacon which is a protocol created by Apple.  There is a beacon protocol by Google called Eddystone. Eddystone doesn't seem to have caught on like iBeacons did.  Eddystone is currently not a supported with Shiny.&lt;/p&gt;
&lt;h2 id="terminology"&gt;Terminology&lt;/h2&gt;
&lt;p&gt;Beacons are riddled with terms and acronyms.  Let me hopefully clear up the ones that matter.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Identifier&lt;/strong&gt; - this is a string, for you to set how you see fit (within reasons obviously)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UUID (Universally Unique Identifier)&lt;/strong&gt; - This is a GUID in .NET terms.  You could equate this to the city where you live&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Major&lt;/strong&gt; - This is a ushort (uint16).  This would equate to the street on which you live&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Minor&lt;/strong&gt; - This is also a ushort (uint16).  This would equate to your street number.  Thereby, giving you the greatest precision in identification.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ranging&lt;/strong&gt; - Refers to scanning for all beacons within a certain address range.  You can see any and all beacons within your filter parameters as well as how close you are to it.  Think &lt;a href="https://ghostbusters.fandom.com/wiki/P.K.E._Meter"&gt;GhostBuster PKE Meter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Monitoring&lt;/strong&gt; - The art of scanning for a "filtered" set of beacon address in the background.  You don't know how close you are to the target in this mode, only if you are entering the region or leaving it.  If you watch the show "Chernobyl" on HBO - think the equivalent being the dosimeters on the belts of these guys (the clicking - you are in the bad zone) - &lt;a href="https://www.youtube.com/watch?v=uXafEIdkx6c"&gt;Watch Here&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;iOS&lt;/em&gt; - You can monitor 20 beacons (this includes any geofences your app uses as well, so careful here) max&lt;/li&gt;
&lt;li&gt;&lt;em&gt;UWP/Android&lt;/em&gt; - Technically, there is no limit here, but I would stick to 20 as well.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="working-with-beacons-shiny-style"&gt;Working with Beacons - Shiny Style&lt;/h2&gt;
&lt;p&gt;Shiny provides the first fully managed beacon implementation for Android &amp;amp; UWP.  It's reach is only limited currently by the reach of Shiny.BluetoothLE.  For iOS, it simply makes use of the iOS API because Apple hijacks all beacon packets (you can't touch them with raw BLE).&lt;/p&gt;
&lt;h3 id="getting-started"&gt;Getting Started&lt;/h3&gt;
&lt;p&gt;Again, to save some time - the best place to go for getting the initial setup with shiny is &lt;a href="https://aritchie.github.io/introducingshiny"&gt;RIGHT HERE&lt;/a&gt;.  For this article, I'm going to register &lt;a href="https://www.nuget.org/packages/Shiny.Beacons/"&gt;Shiny.Beacons&lt;/a&gt; and &lt;a href="https://www.nuget.org/packages/Shiny.Notifications/"&gt;Shiny.Notifications&lt;/a&gt; for backgrounding in the second part of this post under monitoring.&lt;/p&gt;
&lt;h3 id="android"&gt;Android&lt;/h3&gt;
&lt;p&gt;Other than the normal Android setup for Shiny, you need to add the following to your manifest.xml - we'll need a few bluetooth permissions here.  Bluetooth on Android requires location permissions as well as Bluetooth since Android 6 due to the use of beacons.&lt;/p&gt;
&lt;p&gt;Let's get started with the traditional OS setup (yes UWP is supported, but is left out for now)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&amp;gt;
&amp;lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&amp;gt;

&amp;lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&amp;gt;
&amp;lt;uses-permission android:name="android.permission.BLUETOOTH" /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="ios"&gt;iOS&lt;/h3&gt;
&lt;p&gt;Again, same typical iOS initialization.  Just add the following to your info.plist.  The UIBackgroundModes is required for Beacons since they are location context even though they are bluetooth devices - so just like &lt;a href="https://aritchie.github.io/shiny-geofencing"&gt;Geofences&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;key&amp;gt;NSLocationAlwaysUsageDescription&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;Your message&amp;lt;/string&amp;gt;
&amp;lt;key&amp;gt;NSLocationAlwaysAndWhenInUseUsageDescription&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;Your message&amp;lt;/string&amp;gt;
&amp;lt;key&amp;gt;NSLocationWhenInUseUsageDescription&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;Your message&amp;lt;/string&amp;gt;

&amp;lt;key&amp;gt;UIBackgroundModes&amp;lt;/key&amp;gt;
&amp;lt;array&amp;gt;
    &amp;lt;string&amp;gt;location&amp;lt;/string&amp;gt;
&amp;lt;/array&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="in-your-shared-code"&gt;In Your Shared Code&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System;
using Shiny;
using Shiny.Beacons;
using Shiny.Notifications;
using Microsoft.Extensions.DependencyInjection;


namespace YourNamespace
{
    public class SampleStartup : ShinyStartup
    {
        public override void ConfigureServices(IServiceCollection builder)
        {
            // only necessary for the monitoring - for ranging only you can use UseBeacons()
            builder.UseBeaconRanging&amp;lt;MyBeaconDelegate&amp;gt;();
            builder.UseNotifications();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="ranging"&gt;Ranging&lt;/h3&gt;
&lt;p&gt;Ranging is particularily easy - you can do this right in your viewmodel.  With ranging, you are given the specific beacon with its proximity.  You still have to set a beacon region to monitor that filters by at least your global UUID.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
public class YourViewModel
{
    IDisposable scanSub;


    public YourViewModel()
    {
        this.Start = new Command(() =&amp;gt;
        {
            this.scanSub = Shiny
                .ShinyHost
                .Resolve&amp;lt;IBeaconManager&amp;gt;()
                .WhenRanged(new BeaconRegion(YourUuid))
                .Subscribe(x =&amp;gt; Device.BeginInvokeOnMainThread(() =&amp;gt;                
                    this.Beacons.Add(x)
                ))
        });

        this.Stop = new Command(() =&amp;gt; this.scanSub?.Dispose());
    }


    public ICommand Start { get; }
    public ICommand Stop { get; }
    public IList&amp;lt;Beacon&amp;gt; Beacons { get; private set; }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="monitoring"&gt;Monitoring&lt;/h3&gt;
&lt;p&gt;With monitoring, you aren't given the specific beacon or how close the phone is to the beacon in terms of proximity.  You are basically handed back the filter you used.  This is to protect the privacy of the user (which I actually agree with).  This is a pretty easy task to perform on iOS, but brutally painful to do in Android.  Shiny makes this an absolutely delightful to do.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System;
using System.Threading.Tasks;
using Samples.Models;
using Shiny.Beacons;
using Shiny.Notifications;


namespace YourNamespace
{
    public class MyBeaconDelegate : IBeaconDelegate
    {
        readonly INotificationManager notifications;
        public MyBeaconDelegate(INotificationManager notifications) 
        {
            this.notifications = notifications;
        }


        public async Task OnStatusChanged(BeaconRegionState newStatus, BeaconRegion region)
        {
            await this.notifications.Send(
                $"Beacon Region {newStatus}",
                $"{region.Identifier} - {region.Uuid}/{region.Major}/{region.Minor}"
            );
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="in-closing"&gt;In Closing&lt;/h2&gt;
&lt;p&gt;Give Beacons a try - they are great for a variety of business applications from marketing to employee management&lt;/p&gt;
&lt;h2 id="links"&gt;Links&lt;/h2&gt;
&lt;!--?# DefaultBlogLinks /?--&gt;
&lt;ul&gt;
&lt;li&gt;Shiny.Core - &lt;a href="https://www.nuget.org/packages/Shiny.Core/"&gt;&lt;img src="https://img.shields.io/nuget/v/Shiny.Core.svg?maxAge=2592000" alt="NuGet"&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Shiny.Beacons - &lt;a href="https://www.nuget.org/packages/Shiny.Beacons/"&gt;&lt;img src="https://img.shields.io/nuget/v/Shiny.Beacons.svg?maxAge=2592000" alt="NuGet"&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Shiny.Notifications - &lt;a href="https://www.nuget.org/packages/Shiny.Notifications/"&gt;&lt;img src="https://img.shields.io/nuget/v/Shiny.Notifications.svg?maxAge=2592000" alt="NuGet"&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://estimote.com/products/"&gt;Estimote Beacons&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Geofencing with a Pinch of Notifications - Shiny Style</title>
			<link>https://aritchie.github.io/posts/shiny-geofencing</link>
			<description>&lt;p&gt;GPS &amp;amp; Geofencing is a common need for mobile and IoT platforms alike.  However, mobile platforms with backgrounding in this area are always painful and that is being nice.  We've tried several plugins over the years, but they have all some sort of pain point.  Shiny aims to solve all of these as it provides a lot of base infrastructure to make things... shiny ;)&lt;/p&gt;</description>
			<enclosure url="https://aritchie.github.io/images/toronto_pan.jpg" length="0" type="image" />
			<guid>https://aritchie.github.io/posts/shiny-geofencing</guid>
			<pubDate>Tue, 21 May 2019 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="this-article-has-been-updated-to-shiny-2.0"&gt;THIS ARTICLE HAS BEEN UPDATED TO SHINY 2.0&lt;/h1&gt;
&lt;p&gt;GPS &amp;amp; Geofencing is a common need for mobile and IoT platforms alike.  However, mobile platforms with backgrounding in this area are always painful and that is being nice.  We've tried several plugins over the years, but they have all some sort of pain point.  Shiny aims to solve all of these as it provides a lot of base infrastructure to make things... shiny ;)&lt;/p&gt;
&lt;p&gt;We'll talk about GPS in a future article.  In this article, we'll focus on the geofencing and add in some notifications to make things awesome!&lt;/p&gt;
&lt;h2 id="what-are-geofences"&gt;What Are Geofences?&lt;/h2&gt;
&lt;p&gt;Geofencing is a location-based virtual boundary that uses GPS.  When you enter or exit this boundary, an event is executed in your application code.  A good example of this is a user coming close to your store and triggering a local notification - "Hey Peoples - come buy some stuff.  I'll make a deal you can't refuse".  When the user leaves the area "We're so sorry to see you leave.  Come back again and I'll give you 99% off with this magic code".  It's beautiful.... can be annoying, but if you do it right - you can create a good conversion opportunity.&lt;/p&gt;
&lt;h2 id="geofencing-why"&gt;Geofencing - Why?&lt;/h2&gt;
&lt;p&gt;Geofencing is very efficient on battery for the mobile operating systems.  One of the pitfalls is that it isn't exact in terms of fire times.  Sometimes it can take a couple of minutes before the event is actually triggered.  I often get asked why use a geofence over raw GPS.  The explanation I use is, are you in the mall or not - if you are in the mall, you likely won't have a good GPS signal either.  The calculation for determining the circular area of a geofence is also not 2 lines of code if you need to do the effort yourself using raw GPS.  Geofences are good for when you enter and exit a particular area, GPS is better for real time "where are you".&lt;/p&gt;
&lt;h2 id="pitfalls"&gt;Pitfalls&lt;/h2&gt;
&lt;p&gt;I've also seen a number of "gone bad" geofence routines.  This one implementation tried to register over 300 geofences at startup.... so ya... don't do that.  In fact, iOS limits you to 20 and Android caps it at 60.  You may think "wow that is limiting", but really - it isn't.  If you can't get the job done in 20 geofence registrations, honestly, in my opinion - you're doing something wrong.  I generally set a geofence on the center of a structure/area that I'm interested in and set a circular distance of 200 meters.  This is the perfect balance between battery and quick OS response time in my experience.&lt;/p&gt;
&lt;h2 id="making-it-happen-with-shiny"&gt;Making It Happen With Shiny&lt;/h2&gt;
&lt;p&gt;Do all of your normal Shiny setup - you can read my &lt;a href="https://aritchie.github.io/introducingshiny"&gt;Introducing Shiny&lt;/a&gt; to get going on the general setup stuff.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.nuget.org/packages/Shiny.Locations/"&gt;Shiny.Locations&lt;/a&gt; comes as a separate nuget package, but provides functionality for GPS &amp;amp; Geofencing.&lt;br&gt;
You'll also want to pickup &lt;a href="https://www.nuget.org/packages/Shiny.Notifications/"&gt;Shiny.Notifications&lt;/a&gt; to complete the sample in this article.&lt;/p&gt;
&lt;h3 id="in-your-shared-code"&gt;In Your Shared code&lt;/h3&gt;
&lt;p&gt;First, let's create our geofence delegate.  This is the guy that catches those events in the background.  As with all delegates in Shiny, you can inject your own services as long as they are registered with the Shiny container in your startup file.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Shiny.Locations;

namespace MyNamespace
{
    public class MyGeofenceDelegate : IGeofenceDelegate
    {
        readonly INotificationManager notifications;

        public MyGeofenceDelegate(INotificationManager notifications)
        {
            this.notifications = notifications;
        }


        public async Task OnStatusChanged(GeofenceState newStatus, GeofenceRegion region)
        {
            if (newState == GeofenceState.Entered)
            {
                await this.notifications.Send(new Notification 
                { 
                    Title = "WELCOME!",
                    Message = "It is good to have you back " + region.Identifier 
                });
            }
            else 
            {
                await this.notifications.Send(new Notification 
                { 
                    Title = "GOODBYE!", 
                    Message = "You will be missed at " + region.Identifier
                });
            }
        } 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, let's hook this guy up to Shiny, so we can get everything running&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System;
using Shiny;
using Shiny.Locations;
using Shiny.Notifications;
using Microsoft.Extensions.DependencyInjection;


public class SampleStartup : ShinyStartup
{
    public override void ConfigureServices(IServiceCollection builder)
    {
        builder.UseGeofencing&amp;lt;MyGeofenceDelegate&amp;gt;();
        builder.UseNotifications(true);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="ios"&gt;iOS&lt;/h3&gt;
&lt;p&gt;Only iOS requires a bit of extra configuration.  Just add the following to your info.plist.  The UIBackgroundModes is required for geofencing.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;key&amp;gt;NSLocationAlwaysUsageDescription&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;Your message&amp;lt;/string&amp;gt;
&amp;lt;key&amp;gt;NSLocationAlwaysAndWhenInUseUsageDescription&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;Your message&amp;lt;/string&amp;gt;
&amp;lt;key&amp;gt;NSLocationWhenInUseUsageDescription&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;Your message&amp;lt;/string&amp;gt;

&amp;lt;key&amp;gt;UIBackgroundModes&amp;lt;/key&amp;gt;
&amp;lt;array&amp;gt;
    &amp;lt;string&amp;gt;location&amp;lt;/string&amp;gt;
&amp;lt;/array&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="registering-an-actual-geofence"&gt;Registering an actual Geofence&lt;/h2&gt;
&lt;p&gt;Your viewmodel is the best place to register a geofence.&lt;/p&gt;
&lt;p&gt;Please note that while registering a geofence will request the necessary user permissions through the OS, if the user declines the necessary permission, the method will toss an exception.  It is a good practice to use IGeofenceManager.RequestAccess to know the state of things yourself.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Shiny;
using Shiny.Locations;
using Shiny.Notifications;


public class YourViewModel
{
    public YourViewModel()
    {
        // shiny doesn't usually manage your viewmodels, so we'll do this for now
        var geofences = ShinyHost.Resolve&amp;lt;IGeofenceManager&amp;gt;();
        var notifications = ShinyHost.Resolve&amp;lt;INotificationManager&amp;gt;();

        Register = new Command(async () =&amp;gt; 
        {
            // this is really only required on iOS, but do it to be safe
            var access = await notifications.RequestAccess();
            if (access == AccessState.Available)
            {
                await this.geofences.StartMonitoring(new GeofenceRegion(
                    "CN Tower - Toronto, Canada",
                    new Position(43.6425662, -79.3892508),
                    Distance.FromMeters(200)
                )
                {
                    NotifyOnEntry = true,
                    NotifyOnExit = true,
                    SingleUse = false
                });
            }
        });
    }

    public ICommand Register { get; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="in-closing"&gt;In Closing&lt;/h2&gt;
&lt;p&gt;Geofencing + Notifications is a powerful combination.  Hopefully, Shiny helps make this combo easy for you!&lt;/p&gt;
&lt;h2 id="links"&gt;Links&lt;/h2&gt;
&lt;!--?# DefaultBlogLinks /?--&gt;
&lt;ul&gt;
&lt;li&gt;Shiny.Core - &lt;a href="https://www.nuget.org/packages/Shiny.Core/"&gt;&lt;img src="https://img.shields.io/nuget/v/Shiny.Core.svg?maxAge=2592000" alt="NuGet"&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Shiny.Locations - &lt;a href="https://www.nuget.org/packages/Shiny.Locations/"&gt;&lt;img src="https://img.shields.io/nuget/v/Shiny.Locations.svg?maxAge=2592000" alt="NuGet"&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Shiny.Notifications - &lt;a href="https://www.nuget.org/packages/Shiny.Notifications/"&gt;&lt;img src="https://img.shields.io/nuget/v/Shiny.Notifications.svg?maxAge=2592000" alt="NuGet"&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Background Jobs - Shiny Style</title>
			<link>https://aritchie.github.io/posts/shinyjobs</link>
			<description>&lt;p&gt;Performing background jobs on mobile is a necessity these days whether you are synchronizing data with your background, triggering notifications to say happy birthday, or just tracking your user for every step they make.  With Shiny, I set out to make this process a breeze.  Android has such a beautiful scheduled jobs engine that keeps improving.  iOS is painful mainly because Apple hates your code that isn't UI.  UWP does have a background tasks which work quite well, but lack some structure.  I attempted to bring most of the "pretty" from Android to Xamarin cross platform!&lt;/p&gt;</description>
			<enclosure url="https://aritchie.github.io/images/shiny_logo.png" length="0" type="image" />
			<guid>https://aritchie.github.io/posts/shinyjobs</guid>
			<pubDate>Fri, 03 May 2019 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="this-artcile-has-been-updated-to-shiny-2.0"&gt;THIS ARTCILE HAS BEEN UPDATED TO SHINY 2.0&lt;/h1&gt;
&lt;img src="images/shiny_logo.png" width="100" /&gt; 
&lt;p&gt;Performing background jobs on mobile is a necessity these days whether you are synchronizing data with your background, triggering notifications to say happy birthday, or just tracking your user for every step they make.  With Shiny, I set out to make this process a breeze.  Android has such a beautiful scheduled jobs engine that keeps improving.  iOS is painful mainly because Apple hates your code that isn't UI.  UWP does have a background tasks which work quite well, but lack some structure.  I attempted to bring most of the &amp;quot;pretty&amp;quot; from Android to Xamarin cross platform!&lt;/p&gt;
&lt;p&gt;Jobs is something that is built into the main Shiny library as alot of what it does is the center point of the library and a lot of things will be built on it in the near future :)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="getting-setup"&gt;Getting Setup&lt;/h2&gt;
&lt;p&gt;Obviously, first things first - install the &lt;?# NugetShield "Shiny.Core" /?&gt; package into your head projects as well as your shared project.&lt;/p&gt;
&lt;p&gt;And for your Info.plist&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;key&amp;gt;UIBackgroundModes&amp;lt;/key&amp;gt;
&amp;lt;array&amp;gt;
	&amp;lt;string&amp;gt;fetch&amp;lt;/string&amp;gt;
&amp;lt;/array&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="adhoc-jobs"&gt;Adhoc Jobs&lt;/h2&gt;
&lt;p&gt;Adhoc jobs are on-the-spot types of execution.  You need something to finish before your app takes a dirt nap... this is the guy to call&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// IJobManager can and should be injected into your viewmodel code
await Shiny.ShinyHost.Resolve&amp;lt;Shiny.Jobs.IJobManager&amp;gt;().RunTask(async () =&amp;gt; 
{
    // your code goes here - async stuff is welcome (and necessary)
});
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="scheduled-jobs"&gt;Scheduled Jobs&lt;/h2&gt;
&lt;p&gt;Scheduled jobs are the real meat though.  These are really what you need to make things happen when your app is backgrounded or needs to do something with some degree of regularity.  Don't go crazy, you still only get a finite amount of time to work with.  On iOS, this is 30 seconds and not a drop more.&lt;/p&gt;
&lt;p&gt;Note that jobs support injecting your dependencies if they are registered within the Shiny Startup&lt;/p&gt;
&lt;p&gt;So first things first, let's build a job.  Building a job is as simple as implementing Shiny.Jobs.IJob.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class YourFirstJob : Shiny.Jobs.IJob
{
    readonly IYourDepdendency depdency;
    public YourFirstJob(IYourDependency dependency)
    {
        this.dependency = dependency;
    }


    public async Task&amp;lt;bool&amp;gt; Run(JobInfo jobInfo, CancellationToken cancelToken)
    {
        var id = jobInfo.GetValue(&amp;quot;Id&amp;quot;, 25); // we'll cover this in a minute
        await this.dependency.SomeAsyncMethod(id);

        return true; // this is for iOS - try not to lie about this - return true when you actually do receive new data from the remote method
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lastly, you have to register your job.  With scheduled jobs, I wanted to make sure that I could pass in metadata like last date run, some sort of identifiers, etc.  You also have the ability to set to preconditions of when your job is allowed to run.  Maybe you don't want to run unless you are on WiFi because you want to sync like 500+ megs?  Maybe you are going to run an infinite loop that melts the battery, so you want the battery to be charging or at least be above 20% - well, this is the place to make that happen.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var job = new JobInfo
{
    Name = &amp;quot;YourFirstJob&amp;quot;,
    Type = typeof(YourFirstJob),

    // these are criteria that must be met in order for your job to run
    BatteryNotLow = true,
    DeviceCharging = false
    RequiredInternetAccess = InternetAccess.Any,
    Repeat = true //defaults to true, set to false to run once OR set it inside a job to cancel further execution
};

// you can pass variables to your job
job.SetValue(&amp;quot;Id&amp;quot;, 10);


// lastly, schedule it to go - don't worry about scheduling something more than once, we just update if your job name matches an existing one
await ShinyHost.Resolve&amp;lt;Shiny.Jobs.IJobManager&amp;gt;().Schedule(job);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is good for registering jobs in a controlled fashion in your viewmodel.&lt;/p&gt;
&lt;p&gt;However, if you have a service that you always want to run with your app, you can use a quick trick as part of your shiny startup file.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
namespace YourNamespace
{
    public class Startup : Shiny.ShinyStartup
    {
        var job = new JobInfo
        {
            Name = &amp;quot;YourFirstJob&amp;quot;,
            Type = typeof(YourFirstJob),

            // these are criteria that must be met in order for your job to run
            BatteryNotLow = true,
            DeviceCharging = false
            RequiredInternetAccess = InternetAccess.Any,
            Repeat = true //defaults to true, set to false to run once OR set it inside a job to cancel further execution
        };

        services.RegisterJob(job);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="canceling-jobs"&gt;Canceling Jobs&lt;/h2&gt;
&lt;p&gt;When your user logs out, you likely don't need to keep sucking away at their battery, so cancelling jobs is a necessary action to perform.  You have to ways to cancel jobs, by the specific ID of what you registered as the job name OR cancelling ALL jobs.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Cancelling A Job
Shiny.ShinyHost.Resolve&amp;lt;Shiny.Jobs.IJobManager&amp;gt;().Cancel(&amp;quot;YourJobName&amp;quot;);

// Cancelling All Jobs
Shiny.ShinyHost.Resolve&amp;lt;Shiny.Jobs.IJobManager&amp;gt;().CancelAll();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="running-on-demand"&gt;Running On-Demand&lt;/h2&gt;
&lt;p&gt;Unlike adhoc jobs, this is designed to run your registered job(s) when you need them.  On iOS, maybe you are using silent push notifications to give your app a kick to start pulling a gig of data?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Run All Jobs On-Demand
var results = await Shiny.ShinyHost.Resolve&amp;lt;Shiny.Jobs.IJobManager&amp;gt;().RunAll();

// Run A Specific Job On-Demand
var result = await Shiny.ShinyHost.Resolve&amp;lt;Shiny.Jobs.IJobManager&amp;gt;().Run(&amp;quot;YourJobName&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NOTE: you can see the result(s) of a job pass by taking a look at the result object!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="ios-be-prepared"&gt;IOS - Be Prepared&lt;/h2&gt;
&lt;p&gt;iOS is not &amp;quot;periodic&amp;quot; in the sense that you can rely on it to run every X mins.  In fact, it is quite intelligent about when/how it runs.  Do remember, you are piggybacking on &amp;quot;background fetch&amp;quot;, so you really need to do some sort of remote data call if you don't want to aggrevate the apple gods that be.&lt;/p&gt;
&lt;h2 id="links"&gt;Links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;?# ConfiguredLink "Documentation" /?&gt;
&lt;/li&gt;
&lt;li&gt;&lt;?# ConfiguredLink "Samples" /?&gt;
&lt;/li&gt;
&lt;li&gt;&lt;?# ConfiguredLink "GitHub" /?&gt;
&lt;/li&gt;
&lt;li&gt;&lt;?# ConfiguredLink "AllNugets" /?&gt;
&lt;/li&gt;
&lt;li&gt;&lt;?# NugetShield "Shiny.Core" /?&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Introducing Shiny</title>
			<link>https://aritchie.github.io/posts/introducingshiny</link>
			<description>&lt;p&gt;Ever wanted to write a backgrounding experience that is consistent across all of the .NET platforms you work with?  Between Xamarin Android, Xamarin iOS, and the Universal Windows Platform (UWP) - there are a variety of issues that I've seen commonly occuring that makes this difficult.  As .NET developers, we often want our dependency injection, our async/awaits, and our general way of doing things in our ecosystem.  The mobile platforms really flipped us on our head.  Android has services &amp;amp; broadcast receivers, iOS has too many different ways of coming at backgrounding, and UWP is somewhere in between.&lt;/p&gt;</description>
			<enclosure url="https://aritchie.github.io/images/shiny_logo.png" length="0" type="image" />
			<guid>https://aritchie.github.io/posts/introducingshiny</guid>
			<pubDate>Wed, 01 May 2019 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="this-article-was-for-shiny-1.x-and-now-deprecated"&gt;THIS ARTICLE WAS FOR SHINY 1.x AND NOW DEPRECATED&lt;/h1&gt;
&lt;h3 id="what-is-it"&gt;What is it?&lt;/h3&gt;
&lt;p&gt;Ever wanted to write a backgrounding experience that is consistent across all of the .NET platforms you work with?  Between Xamarin Android, Xamarin iOS, and the Universal Windows Platform (UWP) - there are a variety of issues that I've seen commonly occuring that makes this difficult.  As .NET developers, we often want our dependency injection, our async/awaits, and our general way of doing things in our ecosystem.  The mobile platforms really flipped us on our head.  Android has services &amp;amp; broadcast receivers, iOS has too many different ways of coming at backgrounding, and UWP is somewhere in between.&lt;/p&gt;
&lt;p&gt;There have been several plugins over time to help combat this problem, but all fail at some point because they lack the necessary infrastructure to bring it all together.  I have seen developers frequently fight this issue with things like BluetoothLE, GPS, Geofencing, background synchronization, etc.  Making this code testable is even harder and often painful to work with.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://aritchie.github.io/images/shiny_logo.png" width="100"&gt; Enter &lt;a href="https://github.com/shinyorg/shiny"&gt;Shiny&lt;/a&gt; - a new framework that tackles problems that no other framework currently tackles - backgrounding and device hardware with all the bells and whistles you are use to in the .NET ecosystem.  Shiny was built on the premise of making depenendency injection and cross platform backgrounding a consistent &amp;amp; testable experience.&lt;/p&gt;
&lt;p&gt;Out of the box, Shiny will offer:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A Centralized Hosting Platform&lt;/li&gt;
&lt;li&gt;Environment (App &amp;amp; Device Information)&lt;/li&gt;
&lt;li&gt;Logging&lt;/li&gt;
&lt;li&gt;Connectivity&lt;/li&gt;
&lt;li&gt;File System &amp;amp; IO Extensions&lt;/li&gt;
&lt;li&gt;Power Management&lt;/li&gt;
&lt;li&gt;Permissions&lt;/li&gt;
&lt;li&gt;Settings&lt;/li&gt;
&lt;li&gt;Background Jobs&lt;/li&gt;
&lt;li&gt;Geofencing&lt;/li&gt;
&lt;li&gt;GPS (Foreground &amp;amp; Background)&lt;/li&gt;
&lt;li&gt;Bluetooth LE (GATT Peripheral &amp;amp; Central)&lt;/li&gt;
&lt;li&gt;Beacons&lt;/li&gt;
&lt;li&gt;Speech Recognition&lt;/li&gt;
&lt;li&gt;HTTP File Transfers&lt;/li&gt;
&lt;li&gt;Sensors&lt;/li&gt;
&lt;li&gt;Notifications&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="why-another-essentials-or-set-of-plugins"&gt;Why Another Essentials or Set of Plugins?&lt;/h3&gt;
&lt;p&gt;Well - to be fair, I've had most of these libraries before some of the other plugins existed.  I also set out to offer a DI and background experience in a cross platform way first.  I also wanted to open the door to other platforms like Tizen, macOS, Linux, Blazor, Uno, &amp;amp; possibly even Meadow as other platforms for the future.  This library has zero focus on UI and will only focus on service processes - I'll leave the frontend stuff to Xamarin Forms &amp;amp; Uno.&lt;/p&gt;
&lt;p&gt;Current plugins also tend to lack features because they need an underlying layer to help keep things in check.  For instance, Plugin.Jobs (one of my plugins) spins up periodic jobs.  These jobs are essentially useless if you can't get your service layer into them in a consistent manner.&lt;/p&gt;
&lt;h2 id="interoperability"&gt;Interoperability&lt;/h2&gt;
&lt;p&gt;Because Shiny sits a bit higher in the execution pipeline (before Xamarin Forms gets going for example), it has its own set of registration principles and bootstrapping.  However, I wanted to play nice with Xamarin Forms &amp;amp; great frameworks like MvvmCross and Prism (shoot to Dan &amp;amp; Brian - you guys are awesome)!  There are already mechanisms to help these frameworks play nice out of the box from Day 1, but there is a roadmap to make this experience nearly seemless in the near future.&lt;/p&gt;
&lt;h3 id="at-its-core"&gt;At It's Core&lt;/h3&gt;
&lt;p&gt;Shiny was built with Reactive Extensions (RX) and Microsoft Extension (DI) out of the box.  The Microsoft.Extensions.DependencyInjection had the greatest balance of speed, flexibility, and forward thinking support.  Reactive Extensions brings a different paradigm of programming which is often seen as complex.  I choose to embrace it because all other ecosystems embrace it fully (RXJS, Flutter, Java, etc).  I argue that RX isn't complex, it is powerful.  Shiny wants to offer that power at its roots!  As for dependency injection, it often has the same set of arguments and that it is slow.  For backgrounding, DI is extremely POWERFUL and gives you your infrastructure &amp;amp; business logic where you need it.  It also makes your code testable!&lt;/p&gt;
&lt;h3 id="lets-see-it-in-action"&gt;Let's see it in action&lt;/h3&gt;
&lt;p&gt;Step 1 - Install from nuget (given)
Step 2 - In your xplat project, create
Step 3 - Create your "Startup" class&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// this sample uses everything imaginable in Core - YOU DO NOT NEED IT ALL
using Shiny;
using Shiny.BluetoothLE;
using Shiny.Beacons;
using Shiny.Logging;
using Shiny.Locations;
using Shiny.Notifications;
using Shiny.Sensors;
using Shiny.SpeechRecognition;
using Shiny.Net.Http;
using Microsoft.Extensions.DependencyInjection;


namespace Samples
{
    public class SampleStart : ShinyStartup
    {
        public override void ConfigureServices(IServiceCollection builder)
        {
            // custom logging
            Log.UseConsole();
            Log.UseDebug();

            // create your infrastructure
            builder.AddSingleton&amp;lt;SampleSqliteConnection&amp;gt;();

            // register all of the acr stuff you want to use
            builder.UseHttpTransfers&amp;lt;SampleDelegate&amp;gt;();
            builder.UseBeacons&amp;lt;SampleDelegate&amp;gt;();
            builder.UseBleCentral();
            builder.UseBlePeripherals();
            builder.UseGpsBackground&amp;lt;SampleDelegate&amp;gt;();
            builder.UseGeofencing&amp;lt;SampleDelegate&amp;gt;();
            builder.UseNotifications();
            builder.UseSpeechRecognition();

            builder.UseAccelerometer();
            builder.UseAmbientLightSensor();
            builder.UseBarometer();
            builder.UseCompass();
            builder.UseDeviceOrientationSensor();
            builder.UseMagnetometer();
            builder.UsePedometer();
            builder.UseProximitySensor();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="step-4-create-some-delegates"&gt;Step 4 - Create Some Delegates&lt;/h3&gt;
&lt;p&gt;Notice those "SampleDelegate" generics above, that's where you register your background handler(s).  It is truly this simple to get up and running.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// again - this runs everything and the kitchen sink - pick and choose what you need
using System;
using System.Threading;
using System.Threading.Tasks;
using Shiny;
using Shiny.Beacons;
using Shiny.BluetoothLE.Central;
using Shiny.Locations;
using Shiny.Jobs;
using Shiny.Net.Http;
using Shiny.Notifications;
using Samples.Models;


namespace Samples
{
    public class SampleAllDelegate : IGeofenceDelegate,
                                     IGpsDelegate,
                                     IBeaconDelegate,
                                     IHttpTransferDelegate,
                                     IBleStateRestoreDelegate,
                                     IJob
    {
        // notice you can inject anything you registered in your application here
        readonly SampleSqliteConnection conn;
        readonly INotificationManager notifications;


        public SampleAllDelegate(SampleSqliteConnection conn, INotificationManager notifications)
        {
            this.conn = conn;
            this.notifications = notifications;
        }



        public async Task OnConnected(IPeripheral peripheral)
        {
        }


        public async Task OnStatusChanged(GeofenceState newStatus, GeofenceRegion region)
        {
        }


        public async Task OnStatusChanged(BeaconRegionState newStatus, BeaconRegion region)
        {
        }


        public async Task&amp;lt;bool&amp;gt; Run(JobInfo jobInfo, CancellationToken cancelToken)
        {
            return true;
        }


        public async Task OnError(HttpTransfer transfer, Exception ex)
        {
        }


        public async Task OnCompleted(HttpTransfer transfer)
        {
        }


        public async Task OnReading(IGpsReading reading)
        {
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="step-5.1-initializing-ios"&gt;Step 5.1 - Initializing iOS&lt;/h3&gt;
&lt;p&gt;iOS is pretty easy - GO to AppDelegate and add the following stuff&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// in your FinishedLaunching method
Shiny.iOSShinyHost.Init(new Startup(), services =&amp;gt; 
{
    // register any platform specific stuff you need here
});

// and add this guy - if you don't use jobs, you won't need it
public override void PerformFetch(UIApplication application, Action&amp;lt;UIBackgroundFetchResult&amp;gt; completionHandler)
    =&amp;gt; JobManager.OnBackgroundFetch(completionHandler);

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="step-5.2-initializing-android"&gt;Step 5.2 - Initializing Android&lt;/h4&gt;
&lt;p&gt;Android requires a fair bit more setup to get going.  Android requires a top level custom Application definition.  This is necessary as the Host needs to be initialized prior to any services or broadcast receivers warming up.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System;
using Android.App;
using Android.Runtime;


[Application]
public class YourApplication : Application
{
    public YourApplication(IntPtr handle, JniHandleOwnership transfer) : base(handle, transfer)
    {
    }


    public override void OnCreate()
    {
        base.OnCreate();
        Shiny.AndroidShinyHost.Init(this, new Startup(), services =&amp;gt; {
            // register any platform specific stuff you need here
        });
    }
}


// and lastly - in your main/current activity

public override void OnRequestPermissionsResult(int requestCode, string[] permissions, Permission[] grantResults)
{
    Shiny.AndroidShinyHost.OnRequestPermissionsResult(requestCode, permissions, grantResults);
    base.OnRequestPermissionsResult(requestCode, permissions, grantResults);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="links"&gt;LINKS&lt;/h2&gt;
&lt;!--?# DefaultBlogLinks /?--&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>